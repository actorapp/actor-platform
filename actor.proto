//////////////////////////////////////////////////////
// Authentication
//////////////////////////////////////////////////////
//Actor now support only one way for authentication - by SMS or phone call.
//Authorization steps:
//1) Request SMS Code by calling RequestAuthCode
//2) If SMS arrives than send Authorization code in RequestAuthCodeSignIn/SignUp
//3) If sms doesn't arrive for a long time - request phone activation by 
//   calling AuthCodeCall
// 
//* If RequestAuthCode return isRegistered = false than use SignUp method else SignIn.
//* If on any step API return PHONE_CODE_EXPIRED than application MUST start 
//authorization process from begining.
//* Each client MUST send valid RSA 2048 bit PublicKey encoded in x.509 format.

// API#0x01
// ResponseRequestAuthCode
// #400: PHONE_NUMBER_INVALID
message RequestRequestAuthCode {
    required int64 phoneNumber = 1;
    required int32 appId = 2;
    required string apiKey = 3;
}

// API#0x02
message ResponseRequestAuthCode {
    required string smsHash = 1;
    required bool isRegistered = 2;
}

// API#0x5A
// ResponseVoid
// #400: PHONE_CODE_EXPIRED
// #400: PHONE_NUMBER_INVALID
message RequestRequestAuthCodeCall {
    required int64 phoneNumber = 1;
    required string smsHash = 2;
    required int32 appId = 3;
    required string apiKey = 4;
}

// API#0x05
message ResponseAuth {
    required int64 publicKeyHash = 1;
    required User user = 2;
    required Config config = 3;
}

// API#0x03
// ResponseAuth
// #400: INVALID_KEY
// #400: PHONE_NUMBER_UNOCCUPIED
// #400: PHONE_CODE_INVALID 
// #400: PHONE_CODE_EXPIRED
// #400: PHONE_CODE_EMPTY
// #400: PHONE_NUMBER_INVALID
message RequestSignIn {
    required int64 phoneNumber = 1;
    required string smsHash = 2;
    required string smsCode = 3;
    required bytes publicKey = 4;
    required bytes deviceHash = 5;
    required string deviceTitle = 6;
    required int32 appId = 7;
    required string appKey = 8;
}

// API#0x04
// ResponseAuth
// #400: INVALID_KEY
// #400: PHONE_CODE_EXPIRED
// #400: PHONE_CODE_EMPTY
// #400: PHONE_NUMBER_INVALID
// #400: NAME_INVALID
message RequestSignUp {
    required int64 phoneNumber = 1;
    required string smsHash = 2;
    required string smsCode = 3;
    required string name = 4;
    required bytes publicKey = 6;
    required bytes deviceHash = 7;
    required string deviceTitle = 8;
    required int32 appId = 9;
    required string appKey = 10;
    required bool isSilent = 11;
}

message AuthItem {
    required int32 id = 1;
    required int32 authHolder = 2;
    required int32 appId = 3;
    required string appTitle = 4;
    required string deviceTitle = 5;
    required int32 authTime = 6;
    required string authLocation = 7;
    optional double latitude = 8;
    optional double longitude = 9;
}

// API#0x50
// ResponseGetAuth
message RequestGetAuth {
}

// API#0x51
message ResponseGetAuth {
    repeated AuthItem userAuths = 1;
}

// API#0x52
// ResponseVoid
message RequestRemoveAuth {
    required int32 id = 1;
}

// API#0x53
// ResponseVoid
message RequestRemoveAllOtherAuths {
}

// API#0x54
// ResponseVoid
message RequestLogout {
}

//////////////////////////////////////////////////////
// Users
//////////////////////////////////////////////////////
//Users are objects that secured by accessHash. You can't load user profile by it's id.
//You can't send message to user without finding it's object in Updates or by calling
//method for user search, contacts import or some other methods.
// 
//Applications need to keep all Users information forever.
// 
//Each User have optional localName - name of user that was set by current user and can be changed
//any time by calling EditUserLocalName method.

enum Sex {
    UNKNOWN = 1;
    MALE = 2;
    FEMALE = 3;
}

message User {
    required int32 id = 1;
    required int64 accessHash = 2;
    required string name = 3;
    optional string localName = 4;
    optional Sex sex = 5;
    repeated int64 keyHashes = 6;
    required int64 phone = 7;
    optional Avatar avatar = 8;
}

// API#0x60
// ResponseSeq
message RequestEditUserLocalName {
    required int32 uid = 1;
    required int64 accessHash = 2;
    required string name = 3;
}

// API#0x10
message UpdateUserAvatarChanged {
    required int32 uid = 1;
    optional Avatar avatar = 2;
}

// API#0x20
message UpdateUserNameChanged {
    required int32 uid = 1;
    required string name = 2;
}

// API#0x33
message UpdateUserLocalNameChanged {
    required int32 uid = 1;
    optional string localName = 2;
}

//////////////////////////////////////////////////////
// Profile
//////////////////////////////////////////////////////

// API#0x35
// ResponseSeq
message RequestEditName {
    required string name = 1;
}

// API#0x1F
// ResponseAvatarChanged
message RequestEditAvatar {
    required FileLocation fileLocation = 1;
}

// API#0x5B
// ResponseSeq
message RequestRemoveAvatar {
}

//////////////////////////////////////////////////////
// Contacts
//////////////////////////////////////////////////////
//Before working with contact list is is useful to import contacts from phone first by calling
//method ImportContacts#0x07.
// 
//All phone numbers MUST be preprocessed before import by some library (like libphonenumber)
//and build international phone number depending on current users phone and/or locale.
// 
//For loading contact list from server use GetContacts#0x57. 
//If during this call there are some updates about contact list change
//it is recommended to call it again. Also applications need to sync contacts on application start.
// 
//For searching for users without adding to contacts list use method FindContacts#0x70.
// 
//For adding/deleting contacts AddContact#0x72 and DeleteContact#0x59.

message PhoneToImport {
    required int64 phoneNumber = 1;
    optional string name = 2;
}

message EmailToImport {
    required string email = 1;
    optional string name = 2;
}

// API#0x07
// ResponseImportContacts
message RequestImportContacts {
    repeated PhoneToImport phones = 1;
    repeated EmailToImport emails = 2;
}

// API#0x08
message ResponseImportContacts {
    repeated User users = 1;
    required int32 seq = 2;
    required bytes states = 3;
}

// API#0x57
// ResponseGetContacts
message RequestGetContacts {
    required string contactsHash = 1;
}

// API#0x58
message ResponseGetContacts {
    repeated User users = 1;
    required bool isNotChanged = 2;
}

// API#0x59
// ResponseSeq
message RequestRemoveContact {
    required int32 uid = 1;
    required int64 accessHash = 2;
}

// API#0x72
// ResponseSeq
message RequestAddContact {
    required int32 uid = 1;
    required int64 accessHash = 2;
}

// API#0x70
// ResponseSearchContacts
message RequestSearchContacts {
    required string request = 1;
}

// API#0x71
message ResponseSearchContacts {
    repeated User users = 1;
}

// API#0x05
message UpdateContactRegistered {
    required int32 uid = 1;
    required bool isSilent = 2;
    required int64 date = 3;
}

// API#0x28
message UpdateContactsAdded {
    repeated int32 uids = 1;
}

// API#0x29
message UpdateContactsRemoved {
    repeated int32 uids = 1;
}

//////////////////////////////////////////////////////
// Messaging
//////////////////////////////////////////////////////
//<h1>Overview</h1>
//Actor can work with encrypted and plain messages in one conversation. For both types of messages API
//contains a bit different methods. Also encrypted and plain messages have different schemes.
//<h1>Messages</h1>
//Message entity contains:
//* PeerType - group chat or private
//* PeerId - group or user id of conversation
//* RandomId - unique id of message that generated by sender. In Encrypted messages random id is encrypted.
//* Date - date of message (calculated on server)
//* Content
//<h1>Message content</h1>
//Message can be one of three basic types of messages: Text Message, File Message and Service message.
//All messages can contain extensions. For example we can send text message and add markdown extension with 
//formatted text in markdown and clients that support this extension will show markdown, and that clients that
//not supported extension then show simple text. File messages can have photo, video or voice extensions.
//Service message can have extensions extensions such as "user added", "group created", "avatar changed", etc.
//<h1>Send messages</h1>
//Sending messages looks same for encrypted and plain messages. Client MUST prepare all required data
//before sending message (for example FastThumb for photo/video/documents) and call required methods. 
//Encrypted messages differs here only by a little different scheme and encryption.
//<h1>WRONG_KEYS and incorrect keys</h1>
//For sending encrypted messages client MUST send messages encrypted for all own and receivers keys.
//If client send encryption with missing, old or incorrect keys it will receive WRONG_KEYS.
//In WRONG_KEYS you need to deserialize relatedData from RpcError to WrongKeysErrorData
//and get detailed information about keys. Sometimes there are some broken keys on server and client can't 
//encrypt messages with it than client MUST send empty encrypted key in request elsewhere API return WRONG_KEYS.
//<h1>Encrypted messages and New Devices</h1>
//When you send message to someone and when he registered with new device there are no way to receive old encrypted
//messages on new device and because of this there are a problem about read/delivery statuses. 
//Alice send messages to Bob, but Bob lose his device and  buy new iPhone and installed Actor.
//Alice receive notification about new device and send another message. Bob open chat with Alice and
//send read status with maximum message read date. Alice will mark all sent messages as read and one that
//was not delivered. We can use status notifications per message, but in VERY heavy conversations it will be
//a lot of unnecessary traffic. For resolving this small issue we have different ways of message statuses
//for encrypted and plain messages. Also it is recomended to mark all undelivered messages on new device update as 
//not devered with warring sign.
//<h1>Message Read and Delivery</h1>
//There are two different ways for read and delivery statuses for encrypted and plain messages.
//For encrypted messages used status change by RandomId and for plain messages used by maximum
//date of read/delivered message.

message MessageContent {
    required int32 type = 1;
    required bytes content = 2;
}

message TextMessage {
    required string text = 1;
    required int32 extType = 2;
    optional bytes ext = 3;
}

message ServiceMessage {
    required string text = 1;
    required int32 extType = 2;
    optional bytes ext = 3;
}

message ServiceExUserAdded {
    required int32 addedUid = 1;
}

message ServiceExUserKicked {
    required int32 kickedUid = 1;
}

message ServiceExUserLeft {
}

message ServiceExGroupCreated {
}

message ServiceExChangedTItle {
    required string title = 1;
}

message ServiceExChangedAvatar {
    optional Avatar avatar = 1;
}

message FileMessage {
    required int64 fileId = 1;
    required int64 accessHash = 2;
    required int32 fileSize = 3;
    required string name = 4;
    required string mimeType = 5;
    optional FastThumb thumb = 6;
    required int32 extType = 7;
    optional bytes ext = 8;
}

message FileExPhoto {
    required int32 w = 1;
    required int32 h = 2;
}

message FileExVideo {
    required int32 w = 1;
    required int32 h = 2;
    required int32 duration = 3;
}

message FileExVoice {
    required int32 duration = 1;
}

message WrongKeysErrorData {
    repeated UserKey newKeys = 1;
    repeated UserKey removedKeys = 2;
    repeated UserKey invalidKeys = 3;
}

// API#0x73
message ResponseMessageSent {
    required int32 seq = 1;
    required bytes state = 2;
    required int64 date = 3;
}

message EncryptedAesKey {
    required int64 keyHash = 1;
    required bytes aesEncryptedKey = 2;
}

// API#0x0E
// ResponseMessageSent
message RequestSendEncryptedMessage {
    required OutPeer peer = 1;
    required int64 rid = 3;
    required bytes encryptedMessage = 4;
    repeated EncryptedAesKey keys = 5;
    repeated EncryptedAesKey ownKeys = 6;
}

// API#0x5C
// ResponseMessageSent
message RequestSendMessage {
    required OutPeer peer = 1;
    required int64 rid = 3;
    required MessageContent message = 4;
}

// API#0x74
// ResponseVoid
message RequestEncryptedReceived {
    required OutPeer peer = 1;
    required int64 rid = 3;
}

// API#0x75
// ResponseVoid
message RequestEncryptedRead {
    required OutPeer peer = 1;
    required int64 rid = 3;
}

// API#0x37
// ResponseVoid
message RequestMessageReceived {
    required OutPeer peer = 1;
    required int64 rid = 3;
}

// API#0x39
// ResponseVoid
message RequestMessageRead {
    required OutPeer peer = 1;
    required int64 date = 3;
}

// API#0x62
// ResponseVoid
message RequestDeleteMessage {
    required OutPeer peer = 1;
    required int64 rid = 3;
}

// API#0x63
// ResponseSeq
message RequestClearChat {
    required OutPeer peer = 1;
}

// API#0x64
// ResponseSeq
message RequestDeleteChat {
    required OutPeer peer = 1;
}

// API#0x01
message UpdateEncryptedMessage {
    required Peer peer = 1;
    required int32 senderUid = 2;
    required int64 date = 6;
    required int64 keyHash = 3;
    required bytes aesEncryptedKey = 4;
    required bytes message = 5;
}

// API#0x37
message UpdateMessage {
    required Peer peer = 1;
    required int32 senderUid = 2;
    required int64 date = 3;
    required int64 rid = 4;
    required MessageContent message = 5;
}

// API#0x04
message UpdateMessageSent {
    required Peer peer = 1;
    required int64 rid = 2;
    required int64 date = 3;
}

// API#0x12
message UpdateEncryptedReceived {
    required Peer peer = 1;
    required int64 rid = 2;
    required int64 receivedDate = 3;
}

// API#0x34
message UpdateEncryptedRead {
    required Peer peer = 1;
    required int64 rid = 2;
    required int64 readDate = 3;
}

// API#0x35
message UpdateEncryptedReadByMe {
    required Peer peer = 1;
    required int64 rid = 2;
}

// API#0x36
message UpdateMessageReceived {
    required Peer peer = 1;
    required int64 date = 2;
    required int64 receivedDate = 3;
}

// API#0x13
message UpdateMessageRead {
    required Peer peer = 1;
    required int64 date = 2;
    required int64 readDate = 3;
}

// API#0x32
message UpdateMessageReadByMe {
    required Peer peer = 1;
    required int64 date = 2;
}

// API#0x2E
message UpdateMessageDelete {
    required Peer peer = 1;
    repeated int64 rid = 2;
}

// API#0x2F
message UpdateChatClear {
    required Peer peer = 1;
}

// API#0x30
message UpdateChatDelete {
    required Peer peer = 1;
}

//////////////////////////////////////////////////////
// Groups
//////////////////////////////////////////////////////

message Group {
    required int32 id = 1;
    required int64 accessHash = 2;
    required string title = 3;
    optional Avatar avatar = 4;
    required bool isMember = 6;
    required int32 adminUid = 8;
    repeated int32 members = 9;
}

// API#0x41
// ResponseCreateGroup
message RequestCreateGroup {
    required int64 rid = 1;
    required string title = 2;
    repeated UserOutPeer users = 3;
}

// API#0x42
message ResponseCreateGroup {
    required GroupOutPeer groupPeer = 1;
    required int32 seq = 3;
    required bytes state = 4;
    required int32 users = 5;
}

// API#0x55
// ResponseSeq
message RequestEditGroupTitle {
    required GroupOutPeer groupPeer = 1;
    required string title = 3;
}

// API#0x56
// ResponseAvatarChanged
message RequestEditGroupAvatar {
    required GroupOutPeer groupPeer = 1;
    required FileLocation fileLocation = 3;
}

// API#0x65
// ResponseSeq
message RequestRemoveGroupAvatar {
    required GroupOutPeer groupPeer = 1;
}

// API#0x45
// ResponseSeq
message RequestInviteUsers {
    required GroupOutPeer groupPeer = 1;
    repeated UserOutPeer users = 3;
}

// API#0x46
// ResponseSeq
message RequestLeaveGroup {
    required GroupOutPeer groupPeer = 1;
}

// API#0x61
// ResponseSeq
message RequestDeleteGroup {
    required GroupOutPeer groupPeer = 1;
}

// API#0x47
// ResponseSeq
message RequestRemoveUsers {
    required GroupOutPeer groupPeer = 1;
    repeated UserOutPeer users = 3;
}

// API#0x24
message UpdateGroupInvite {
    required int32 groupId = 1;
    required int32 inviteUid = 5;
    required int64 date = 8;
}

// API#0x15
message UpdateGroupUserAdded {
    required int32 groupId = 1;
    required int32 uid = 2;
    required int32 inviterUid = 3;
    required int64 date = 4;
}

// API#0x17
message UpdateGroupUserLeave {
    required int32 groupId = 1;
    required int32 uid = 2;
    required int64 date = 3;
}

// API#0x18
message UpdateGroupUserKick {
    required int32 groupId = 1;
    required int32 uid = 2;
    required int32 kickerUid = 3;
    required int64 date = 4;
}

// API#0x2C
message UpdateGroupMembersUpdate {
    required int32 groupId = 1;
    repeated int32 members = 2;
}

// API#0x26
message UpdateGroupTitleChanged {
    required int32 groupId = 1;
    required int32 uid = 2;
    required string title = 3;
    required int64 date = 4;
}

// API#0x27
message UpdateGroupAvatarChanged {
    required int32 groupId = 1;
    required int32 uid = 2;
    optional Avatar avatar = 3;
    required int64 date = 4;
}

//////////////////////////////////////////////////////
// Message and Dialogs lists
//////////////////////////////////////////////////////
//<h1>Overview</h1>
//Actor can work with encrypted and plain messages and encrypted messages does not appear in history,
//but it affects conversation lists.
//<h1>Messages ordering</h1>
//Server provide date in milliseconds for accurate ordering of incoming messages in applications. 
//NOTHING can move conversation on conversation list down on list. For example if you clean chat or delete top message
//for the conversation conversation keep its position. Some events doesn't move conversation to top
//of conversations list. For example leaving chat or new device notification doesn't move it up.
//<h1>Deleting of messages</h1>
//For deletion of messages either plain or encrypted there is method MessageDelete#0x62 deletion.
//Deletion of message is irreversible for now.
//<h1>Deleting and clearing of conversation</h1>
//Clearing of conversation deletes all messages in conversation and clears top message in conversation list.
//Deletion of conversation deletes all messages and removes conversation from conversations list.
//For sync this operations there are updates ChatDelete#0x30 and ChatClear#0x2F.
//Deletion by ChatDelete of group causes automatic group leaving.
//<h1>Loading history</h1>
//For loading conversation list use method LoadDialogs#0x68. 
//When top message in conversation is encrypted than dialog item will contain empty text. Dialog item contains
//two dates - visual and sort, visual used for displaying date and sort for sorting dialog in dialog list.
// 
//For loading history of conversation use method LoadHistory#0x68.
// 
//Loading initial list are called with zero startDate and after loading more messages 
//we will use maximum date from messages for startDate value.

message HistoryMessage {
    required int32 senderUid = 1;
    required int64 rid = 2;
    required int64 date = 3;
    required MessageContent message = 5;
}

// API#0x76
// ResponseLoadHistory
message RequestLoadHistory {
    required OutPeer peer = 1;
    required int64 startDate = 3;
    required int32 limit = 4;
}

// API#0x77
message ResponseLoadHistory {
    repeated HistoryMessage history = 1;
    repeated User users = 2;
}

message Dialog {
    required Peer peer = 1;
    required int32 unreadCount = 3;
    required int64 sortDate = 4;
    required int32 senderUid = 5;
    required int64 rid = 6;
    required int64 date = 7;
    required MessageContent message = 8;
}

// API#0x68
// ResponseLoadDialogs
message RequestLoadDialogs {
    required int64 startDate = 1;
    required int32 limit = 2;
}

// API#0x69
message ResponseLoadDialogs {
    repeated Group groups = 1;
    repeated User users = 2;
    repeated Dialog dialogs = 3;
}

//////////////////////////////////////////////////////
// Encryption
//////////////////////////////////////////////////////

message UserKey {
    required int32 uid = 1;
    required int64 keyHash = 2;
}

message PublicKey {
    required int32 uid = 1;
    required int64 keyHash = 2;
    required bytes key = 3;
}

// API#0x02
message UpdateNewDevice {
    required int32 uid = 1;
    required int64 keyHash = 2;
    optional bytes key = 3;
    required int64 date = 4;
}

// API#0x25
message UpdateRemovedDevice {
    required int32 uid = 1;
    required int64 keyHash = 2;
}

message PublicKeyRequest {
    required int32 uid = 1;
    required int64 accessHash = 2;
    required int64 keyHash = 3;
}

// API#0x06
// ResponseGetPublicKeys
message RequestGetPublicKeys {
    repeated PublicKeyRequest keys = 1;
}

// API#0x18
message ResponseGetPublicKeys {
    repeated PublicKey keys = 1;
}

//////////////////////////////////////////////////////
// Typing and Online
//////////////////////////////////////////////////////

// API#0x1B
// ResponseVoid
message RequestTyping {
    required OutPeer peer = 1;
    required int32 typingType = 3;
}

// API#0x1D
// ResponseVoid
message RequestSetOnline {
    required bool isOnline = 1;
    required int64 timeout = 2;
}

// API#0x06
message UpdateTyping {
    required Peer peer = 1;
    required int32 uid = 2;
    required int32 typingType = 3;
}

// API#0x07
message UpdateUserOnline {
    required int32 uid = 1;
}

// API#0x08
message UpdateUserOffline {
    required int32 uid = 1;
}

// API#0x09
message UpdateUserLastSeen {
    required int32 uid = 1;
    required int64 time = 2;
}

// API#0x21
message UpdateGroupOnline {
    required int32 groupId = 1;
    required int32 count = 2;
}

//////////////////////////////////////////////////////
// Media and Files
//////////////////////////////////////////////////////

message FileLocation {
    required int64 fileId = 1;
    required int64 accessHash = 2;
}

message AvatarImage {
    required FileLocation fileLocation = 1;
    required int32 width = 2;
    required int32 height = 3;
    required int32 fileSize = 4;
}

message Avatar {
    optional AvatarImage smallImage = 1;
    optional AvatarImage largeImage = 2;
    optional AvatarImage fullImage = 3;
}

message FastThumb {
    required int32 w = 1;
    required int32 h = 2;
    required bytes thumb = 3;
}

// API#0x10
// ResponseGetFile
message RequestGetFile {
    required FileLocation fileLocation = 1;
    required int32 offset = 2;
    required int32 limit = 3;
}

// API#0x11
message ResponseGetFile {
    required bytes payload = 1;
}

message UploadConfig {
    required bytes serverData = 1;
}

// API#0x12
// ResponseStartUpload
message RequestStartUpload {
}

// API#0x13
message ResponseStartUpload {
    required UploadConfig config = 1;
}

// API#0x14
// ResponseVoid
message RequestUploadPart {
    required UploadConfig config = 1;
    required int32 blockIndex = 2;
    required bytes payload = 3;
}

// API#0x16
// ResponseCompleteUpload
message RequestCompleteUpload {
    required UploadConfig config = 1;
    required int32 blocksCount = 2;
    required int64 crc32 = 3;
}

// API#0x17
message ResponseCompleteUpload {
    required FileLocation location = 1;
}

//////////////////////////////////////////////////////
// Push
//////////////////////////////////////////////////////

// API#0x33
// ResponseVoid
message RequestRegisterGooglePush {
    required int64 projectId = 1;
    required string token = 2;
}

// API#0x4C
// ResponseVoid
message RequestRegisterApplePush {
    required int32 apnsKey = 1;
    required string token = 2;
}

// API#0x34
// ResponseVoid
message RequestUnregisterPush {
}

//////////////////////////////////////////////////////
// Peers
//////////////////////////////////////////////////////

enum PeerType {
    PRIVATE = 1;
    GROUP = 2;
}

message Peer {
    required PeerType type = 1;
    required int32 id = 2;
}

message OutPeer {
    required PeerType type = 1;
    required int32 id = 2;
    required int64 accessHash = 3;
}

message UserOutPeer {
    required int32 uid = 1;
    required int64 accessHash = 2;
}

message GroupOutPeer {
    required int32 groupId = 1;
    required int64 accessHash = 2;
}

//////////////////////////////////////////////////////
// Sequence and Updates
//////////////////////////////////////////////////////

// API#0x0D
message UpdateSeqUpdate {
    required int32 seq = 1;
    required bytes state = 2;
    required int32 updateHeader = 3;
    required bytes update = 4;
}

// API#0x49
message UpdateFatSeqUpdate {
    required int32 seq = 1;
    required bytes state = 2;
    required int32 updateHeader = 3;
    required bytes update = 4;
    repeated User users = 5;
    repeated Group groups = 6;
}

// API#0x1A
message UpdateWeakUpdate {
    required int64 date = 1;
    required int32 updateId = 2;
    required bytes update = 3;
}

// API#0x19
message UpdateSeqUpdateTooLong {
}

// API#0x09
// ResponseSeq
message RequestGetState {
}

message DifferenceUpdate {
    required int32 updateId = 1;
    required bytes update = 2;
}

// API#0x0B
// ResponseGetDifference
message RequestGetDifference {
    required int32 seq = 1;
    required bytes state = 2;
}

// API#0x0C
message ResponseGetDifference {
    required int32 seq = 1;
    required bytes state = 2;
    repeated User users = 3;
    repeated Group groups = 6;
    repeated DifferenceUpdate updates = 4;
    required bool needMode = 5;
}

// API#0x20
// ResponseVoid
message RequestSubscribeToOnline {
    repeated UserOutPeer users = 1;
}

// API#0x21
// ResponseVoid
message RequestSubscribeFromOnline {
    repeated UserOutPeer users = 1;
}

// API#0x4A
// ResponseVoid
message RequestSubscribeToGrouOnline {
    repeated GroupOutPeer groups = 1;
}

// API#0x4B
// ResponseVoid
message RequestSubscribeFromGroupOnline {
    repeated GroupOutPeer groups = 1;
}

//////////////////////////////////////////////////////
// Common
//////////////////////////////////////////////////////

// API#0x32
message ResponseVoid {
}

// API#0x48
message ResponseSeq {
    required int32 seq = 1;
    required bytes state = 2;
}

// API#0x44
message ResponseAvatarChanged {
    required Avatar avatar = 1;
    required int32 seq = 2;
    required bytes state = 3;
}

message Config {
    required int32 maxGroupSize = 1;
}

// API#0x2A
message UpdateConfig {
    required Config config = 1;
}

