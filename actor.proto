//////////////////////////////////////////////////////
// Authentication
//////////////////////////////////////////////////////
//<p>Actor now support only one way for authentication - by SMS or phone call.</p>
//<p>Authorization steps:
//<ol>
//<li>Request SMS Code by calling RequestAuthCode</li>
//<li>If SMS arrives than send Authorization code in SignIn/SignUp</li>
//<li>If sms doesn't arrive for a long time - request phone activation by 
//   calling AuthCodeCall</li>
//</ol>
//</p>
//Some rules<br/>
//If RequestAuthCode return isRegistered = false than use SignUp method else SignIn.<br/>
//If on any step API return PHONE_CODE_EXPIRED than application MUST start 
//authorization process from begining.<br/>
//Each client MUST send valid RSA 2048 bit PublicKey encoded in x.509 format.<br/>

// API#0x01
// ResponseAuthCode
// Requesting SMS auth code
// phoneNumberPhone number in international format
// appIdApplication ID
// apiKeyApplication API key
message RequestAuthCode {
    required int64 phoneNumber = 1;
    required int32 appId = 2;
    required string apiKey = 3;
}

// API#0x02
message ResponseAuthCode {
    required string smsHash = 1;
    required bool isRegistered = 2;
}

// API#0x5A
// ResponseVoid
// Requesting Phone activation
// phoneNumberPhone number in international format
// smsHashCode request hash from RequestAuthCode
// appIdApplication ID
// apiKeyApplication API key
message RequestAuthCodeCall {
    required int64 phoneNumber = 1;
    required string smsHash = 2;
    required int32 appId = 3;
    required string apiKey = 4;
}

// API#0x05
// Authentication result
// publicKeyHash  Public Key Hash of current authentication
// user  The authenticated User
// config  Current config of server
message ResponseAuth {
    required int64 publicKeyHash = 1;
    required User user = 2;
    required Config config = 3;
}

// API#0x03
// ResponseAuth
// Performing user signin
// phoneNumberPhone number in international format
// smsHashCode request hash from RequestAuthCode
// smsCodeConfirmation code from SMS
// publicKeyDevice RSA 2048 bit public key in x.509 format
// deviceHashHash of device unique id and app bundle id. Used for autologout users when app is reinstalled
// deviceTitleDevice title like 'Steven's iPhone'
// appIdApplication ID
// appKeyApplication API key
message RequestSignIn {
    required int64 phoneNumber = 1;
    required string smsHash = 2;
    required string smsCode = 3;
    required bytes publicKey = 4;
    required bytes deviceHash = 5;
    required string deviceTitle = 6;
    required int32 appId = 7;
    required string appKey = 8;
}

// API#0x04
// ResponseAuth
// Performing user signup. If user perform signup on already registered user it just override previous
// profile information
// phoneNumberPhone number in international format
// smsHashCode request hash from RequestAuthCode
// smsCodeConfirmation code from SMS
// nameUser name
// publicKeyDevice RSA 2048 bit public key in x.509 format
// deviceHashHash of device unique id and app bundle id. Used for autologout users when app is reinstalled
// deviceTitleDevice title like 'Steven's iPhone'
// appIdApplication ID
// appKeypplication API key
message RequestSignUp {
    required int64 phoneNumber = 1;
    required string smsHash = 2;
    required string smsCode = 3;
    required string name = 4;
    required bytes publicKey = 6;
    required bytes deviceHash = 7;
    required string deviceTitle = 8;
    required int32 appId = 9;
    required string appKey = 10;
    required bool isSilent = 11;
}

// Authentication session
// id  Unuque ID of session
// authHolder  holder of session. 0 - this device, 1 - other.
// appId  Application Id (user in SignIn/SignUp)
// appTitle  Title of application
// deviceTitle  Title of device
// authTime  Time of session creating
// authLocation  two-letter country code of session create
// latitude  optional latitude of auth if available
// longitude  optional longitude of auth if available
message AuthItem {
    required int32 id = 1;
    required int32 authHolder = 2;
    required int32 appId = 3;
    required string appTitle = 4;
    required string deviceTitle = 5;
    required int32 authTime = 6;
    required string authLocation = 7;
    optional double latitude = 8;
    optional double longitude = 9;
}

// API#0x50
// ResponseGetAuth
// Getting of all active user's authentication sessions
message RequestGetAuth {
}

// API#0x51
message ResponseGetAuth {
    repeated AuthItem userAuths = 1;
}

// API#0x52
// ResponseVoid
// Logout on specified user's session
// idid from AuthItem
message RequestRemoveAuth {
    required int32 id = 1;
}

// API#0x53
// ResponseVoid
// Logout on all exept current sessions
message RequestRemoveAllOtherAuths {
}

// API#0x54
// ResponseVoid
// Logout current session
message RequestLogout {
}

//////////////////////////////////////////////////////
// Users
//////////////////////////////////////////////////////
//Users are objects that secured by accessHash. You can't load user profile by it's id.
//You can't send message to user without finding it's object in Updates or by calling
//method for user search, contacts import or some other methods.
// 
//Applications need to keep all Users information forever.
// 
//Each User have optional localName - name of user that was set by current user and can be changed
//any time by calling EditUserLocalName method.

enum Sex {
    UNKNOWN = 1;
    MALE = 2;
    FEMALE = 3;
}

// Main user object
// id  uid
// accessHash  user's access hash
// name  user's name
// localName  user's local name
// sex  optional sex of user
// keyHashes  key hashes of user
// phone  Phone number of user
// avatar  avatar of user
message User {
    required int32 id = 1;
    required int64 accessHash = 2;
    required string name = 3;
    optional string localName = 4;
    optional Sex sex = 5;
    repeated int64 keyHashes = 6;
    required int64 phone = 7;
    optional Avatar avatar = 8;
}

// API#0x60
// ResponseSeq
// Renaming of user's visible name
// uidtarget User's uid
// accessHashUser's accessHash
// nameNew user name
message RequestEditUserLocalName {
    required int32 uid = 1;
    required int64 accessHash = 2;
    required string name = 3;
}

// API#0x10
// Update about avatar changed
// uid  user's uid
// avatar  user's new avatar
message UpdateUserAvatarChanged {
    required int32 uid = 1;
    optional Avatar avatar = 2;
}

// API#0x20
// Update about name changed
// uid  user's uid
// name  user's name
message UpdateUserNameChanged {
    required int32 uid = 1;
    required string name = 2;
}

// API#0x33
// Update about local name changed
// uid  user's uid
// localName  new user's local name
message UpdateUserLocalNameChanged {
    required int32 uid = 1;
    optional string localName = 2;
}

//////////////////////////////////////////////////////
// Profile
//////////////////////////////////////////////////////

// API#0x35
// ResponseSeq
// Changing account's name
// nameNew name
message RequestEditName {
    required string name = 1;
}

// API#0x1F
// ResponseAvatarChanged
// Changing account's avatar
// fileLocationFile Location of uploaded unencrypted avatar
message RequestEditAvatar {
    required FileLocation fileLocation = 1;
}

// API#0x5B
// ResponseSeq
// Removing account's avatar
message RequestRemoveAvatar {
}

//////////////////////////////////////////////////////
// Contacts
//////////////////////////////////////////////////////
//Before working with contact list is is useful to import contacts from phone first by calling
//method ImportContacts#0x07.
// 
//All phone numbers MUST be preprocessed before import by some library (like libphonenumber)
//and build international phone number depending on current users phone and/or locale.
// 
//For loading contact list from server use GetContacts#0x57. 
//If during this call there are some updates about contact list change
//it is recommended to call it again. Also applications need to sync contacts on application start.
// 
//For searching for users without adding to contacts list use method FindContacts#0x70.
// 
//For adding/deleting contacts AddContact#0x72 and DeleteContact#0x59.

// Phone for import
// phoneNumber  phone number for import in international format
// name  optional name for contact
message PhoneToImport {
    required int64 phoneNumber = 1;
    optional string name = 2;
}

// Email for import
// email  email for importing
// name  optional name for contact
message EmailToImport {
    required string email = 1;
    optional string name = 2;
}

// API#0x07
// ResponseImportContacts
// Importing phones and emails for building contact list
// Maximum amount of items for import per method call equals to 100.
// phonesPhones for import
// emailsEmails for import
message RequestImportContacts {
    repeated PhoneToImport phones = 1;
    repeated EmailToImport emails = 2;
}

// API#0x08
message ResponseImportContacts {
    repeated User users = 1;
    required int32 seq = 2;
    required bytes states = 3;
}

// API#0x57
// ResponseGetContacts
// Getting current contact list
// SHA256 hash of list of a comma-separated list of contact UIDs in ascending 
// order may be passed in contactsHash parameter. 
// If the contact list was not changed, isNotChanged will be true.
// contactsHashHash of saved list in application
message RequestGetContacts {
    required string contactsHash = 1;
}

// API#0x58
message ResponseGetContacts {
    repeated User users = 1;
    required bool isNotChanged = 2;
}

// API#0x59
// ResponseSeq
// Removing contact from contact list
// uidContact's UID
// accessHashContact's AccessHash
message RequestRemoveContact {
    required int32 uid = 1;
    required int64 accessHash = 2;
}

// API#0x72
// ResponseSeq
// Adding contact to contact list
// uidContact's UID
// accessHashContact's AccessHash
message RequestAddContact {
    required int32 uid = 1;
    required int64 accessHash = 2;
}

// API#0x70
// ResponseSearchContacts
// Searching contacts by user's query
message RequestSearchContacts {
    required string request = 1;
}

// API#0x71
message ResponseSearchContacts {
    repeated User users = 1;
}

// API#0x05
// Update about contact registration
// uid  contact's uid
// isSilent  is registration silent. If this value is true then don't show notification about registration
// date  date of registration
message UpdateContactRegistered {
    required int32 uid = 1;
    required bool isSilent = 2;
    required int64 date = 3;
}

// API#0x28
// Update about contacts added
// uids  added contacts
message UpdateContactsAdded {
    repeated int32 uids = 1;
}

// API#0x29
// Update about contacts removed
// uids  removed contacts
message UpdateContactsRemoved {
    repeated int32 uids = 1;
}

//////////////////////////////////////////////////////
// Messaging
//////////////////////////////////////////////////////
//Actor can work with encrypted and plain messages in one conversation. For both types of messages API
//contains a bit different methods. Also encrypted and plain messages have different schemes.
//<h3>Messages</h3>
//Message entity contains:
//<ul>
//<li>PeerType - group chat or private</li>
//<li>PeerId - group or user id of conversation</li>
//<li>RandomId - unique id of message that generated by sender. In Encrypted messages random id is encrypted.</li>
//<li>Date - date of message (calculated on server)</li>
//<li>Content</li>
//</ul>
//<h3>Message content</h3>
//Message can be one of three basic types of messages: Text Message, File Message and Service message.
//All messages can contain extensions. For example we can send text message and add markdown extension with 
//formatted text in markdown and clients that support this extension will show markdown, and that clients that
//not supported extension then show simple text. File messages can have photo, video or voice extensions.
//Service message can have extensions extensions such as "user added", "group created", "avatar changed", etc.
//<h3>Send messages</h3>
//Sending messages looks same for encrypted and plain messages. Client MUST prepare all required data
//before sending message (for example FastThumb for photo/video/documents) and call required methods. 
//Encrypted messages differs here only by a little different scheme and encryption.
//<h3>WRONG_KEYS and incorrect keys</h3>
//For sending encrypted messages client MUST send messages encrypted for all own and receivers keys.
//If client send encryption with missing, old or incorrect keys it will receive WRONG_KEYS.
//In WRONG_KEYS you need to deserialize relatedData from RpcError to WrongKeysErrorData
//and get detailed information about keys. Sometimes there are some broken keys on server and client can't 
//encrypt messages with it than client MUST send empty encrypted key in request elsewhere API return WRONG_KEYS.
//<h3>Encrypted messages and New Devices</h3>
//When you send message to someone and when he registered with new device there are no way to receive old encrypted
//messages on new device and because of this there are a problem about read/delivery statuses. 
//Alice send messages to Bob, but Bob lose his device and  buy new iPhone and installed Actor.
//Alice receive notification about new device and send another message. Bob open chat with Alice and
//send read status with maximum message read date. Alice will mark all sent messages as read and one that
//was not delivered. We can use status notifications per message, but in VERY heavy conversations it will be
//a lot of unnecessary traffic. For resolving this small issue we have different ways of message statuses
//for encrypted and plain messages. Also it is recomended to mark all undelivered messages on new device update as 
//not devered with warring sign.
//<h3>Message Read and Delivery</h3>
//There are two different ways for read and delivery statuses for encrypted and plain messages.
//For encrypted messages used status change by RandomId and for plain messages used by maximum
//date of read/delivered message.

// Content of message
// type  type of content. 1 => TextMessage, 2 => ServiceMessage, 3 => FileMessage
// content  serialized content of message
message MessageContent {
    required int32 type = 1;
    required bytes content = 2;
}

// Text message
// text  the text
// extType  type of extension. Now there are no extensions.
// ext  Optional bytes of extension
message TextMessage {
    required string text = 1;
    required int32 extType = 2;
    optional bytes ext = 3;
}

// Service message
// text  service message text
// extType  extension type. 0x01 => ServiceExUserAdded, 0x02 => ServiceExUserKicked, 0x03 => ServiveExUserLeft, 0x04 => ServiceExGroupCreated, 0x05 => ServiceExGroupChangedTitle, 0x06 => ServiceExGroupChangedAvatar
message ServiceMessage {
    required string text = 1;
    required int32 extType = 2;
    optional bytes ext = 3;
}

// Service message about adding user to group
// addedUid  added user id
message ServiceExUserAdded {
    required int32 addedUid = 1;
}

// Service message about kicking user from group
// kickedUid  kicked user id
message ServiceExUserKicked {
    required int32 kickedUid = 1;
}

// Service message about user left group
message ServiceExUserLeft {
}

// Service message about group creating
message ServiceExGroupCreated {
}

// Service message about group title change
message ServiceExChangedTitle {
    required string title = 1;
}

// Service message about avatar change
message ServiceExChangedAvatar {
    optional Avatar avatar = 1;
}

// File message
// fileId  file id
// accessHash  file access hash
// fileSize  file size
// name  name of file
// mimeType  mimetype of file
// thumb  optional thumb of file. JPEG less that 90x90 with 60-70 quality.
// extType  Extension type. 0x01 => FileExPhoto, 0x02 => FileExVideo, 0x03 => FileExVoice
message FileMessage {
    required int64 fileId = 1;
    required int64 accessHash = 2;
    required int32 fileSize = 3;
    required string name = 4;
    required string mimeType = 5;
    optional FastThumb thumb = 6;
    required int32 extType = 7;
    optional bytes ext = 8;
}

// File photo extension
// w  image width
// h  image height
message FileExPhoto {
    required int32 w = 1;
    required int32 h = 2;
}

// File video extension
// w  video width
// h  video height
// duration  video duration
message FileExVideo {
    required int32 w = 1;
    required int32 h = 2;
    required int32 duration = 3;
}

// File voice extension
// duration  voice duration
message FileExVoice {
    required int32 duration = 1;
}

// Error's Related data for WRRONG_KEYS in sendMessage
// newKeys  added keys to user
// removedKeys  disabled keys
// invalidKeys  invalid keys
message WrongKeysErrorData {
    repeated UserKey newKeys = 1;
    repeated UserKey removedKeys = 2;
    repeated UserKey invalidKeys = 3;
}

// API#0x73
// Response about message sent
// seq  Sequence number in update sequence
// state  Seuqnce state value
// date  date of message
message ResponseMessageSent {
    required int32 seq = 1;
    required bytes state = 2;
    required int64 date = 3;
}

// Encrypted AES key for encrypted messages
// keyHash  hash of public key of encrypted aes key
// aesEncryptedKey  encrypted aes key
message EncryptedAesKey {
    required int64 keyHash = 1;
    required bytes aesEncryptedKey = 2;
}

// API#0x0E
// ResponseMessageSent
// Sending encrypted message
// peerDestination peer for message
// ridMessage random id (generated on client side)
// encryptedMessagemessage encrypted by random aes key
// keysencrypted aes keys for receivers devices
// ownKeysencrypted aes keys for own devices
message RequestSendEncryptedMessage {
    required OutPeer peer = 1;
    required int64 rid = 3;
    required bytes encryptedMessage = 4;
    repeated EncryptedAesKey keys = 5;
    repeated EncryptedAesKey ownKeys = 6;
}

// API#0x5C
// ResponseMessageSent
// Sending plain message
// peerDestination peer for message (now supported only user's peer)
// ridMessage random id (generated on clien side)
// messageThe message
message RequestSendMessage {
    required OutPeer peer = 1;
    required int64 rid = 3;
    required MessageContent message = 4;
}

// API#0x74
// ResponseVoid
// Confirmation of encrypted message receive by device
// peerDestination peer
// ridMessage random id
message RequestEncryptedReceived {
    required OutPeer peer = 1;
    required int64 rid = 3;
}

// API#0x75
// ResponseVoid
// Marking encrypted message as read
// peerDestination peer
// ridMessage random id
message RequestEncryptedRead {
    required OutPeer peer = 1;
    required int64 rid = 3;
}

// API#0x37
// ResponseVoid
// Confirmation of plain message receive by device
// peerDestination peer
// dateMaximum date of received messages
message RequestMessageReceived {
    required OutPeer peer = 1;
    required int64 date = 3;
}

// API#0x39
// ResponseVoid
// Marking plain messages as read
// peerDestination peer
// dateMaximum date of read messages
message RequestMessageRead {
    required OutPeer peer = 1;
    required int64 date = 3;
}

// API#0x62
// ResponseVoid
// Deleting messages
// peerDestination peer
// ridMessage random id
message RequestDeleteMessage {
    required OutPeer peer = 1;
    repeated int64 rid = 3;
}

// API#0x63
// ResponseSeq
// Clearing of conversation (without removing dialog from dialogs list)
// peerConversation peer
message RequestClearChat {
    required OutPeer peer = 1;
}

// API#0x64
// ResponseSeq
// Deleting of conversation (also leave group for group conversations)
// peerConversation peer
message RequestDeleteChat {
    required OutPeer peer = 1;
}

// API#0x01
// Update about encrypted message
// peer  Destination peer
// senderUid  sender of message
// date  date of message
// keyHash  device's public key hash
// aesEncryptedKey  Encrypted key for current device
message UpdateEncryptedMessage {
    required Peer peer = 1;
    required int32 senderUid = 2;
    required int64 date = 6;
    required int64 keyHash = 3;
    required bytes aesEncryptedKey = 4;
    required bytes message = 5;
}

// API#0x37
// Update about plain message
message UpdateMessage {
    required Peer peer = 1;
    required int32 senderUid = 2;
    required int64 date = 3;
    required int64 rid = 4;
    required MessageContent message = 5;
}

// API#0x04
message UpdateMessageSent {
    required Peer peer = 1;
    required int64 rid = 2;
    required int64 date = 3;
}

// API#0x12
message UpdateEncryptedReceived {
    required Peer peer = 1;
    required int64 rid = 2;
    required int64 receivedDate = 3;
}

// API#0x34
message UpdateEncryptedRead {
    required Peer peer = 1;
    required int64 rid = 2;
    required int64 readDate = 3;
}

// API#0x35
message UpdateEncryptedReadByMe {
    required Peer peer = 1;
    required int64 rid = 2;
}

// API#0x36
message UpdateMessageReceived {
    required Peer peer = 1;
    required int64 date = 2;
    required int64 receivedDate = 3;
}

// API#0x13
message UpdateMessageRead {
    required Peer peer = 1;
    required int64 date = 2;
    required int64 readDate = 3;
}

// API#0x32
message UpdateMessageReadByMe {
    required Peer peer = 1;
    required int64 date = 2;
}

// API#0x2E
message UpdateMessageDelete {
    required Peer peer = 1;
    repeated int64 rid = 2;
}

// API#0x2F
message UpdateChatClear {
    required Peer peer = 1;
}

// API#0x30
message UpdateChatDelete {
    required Peer peer = 1;
}

//////////////////////////////////////////////////////
// Groups
//////////////////////////////////////////////////////

message Group {
    required int32 id = 1;
    required int64 accessHash = 2;
    required string title = 3;
    optional Avatar avatar = 4;
    required bool isMember = 6;
    required int32 adminUid = 8;
    repeated int32 members = 9;
}

// API#0x41
// ResponseCreateGroup
// Creating group chat
// ridRandom Id for avoiding double create
// titleGroup title
// usersMembers of group
message RequestCreateGroup {
    required int64 rid = 1;
    required string title = 2;
    repeated UserOutPeer users = 3;
}

// API#0x42
message ResponseCreateGroup {
    required GroupOutPeer groupPeer = 1;
    required int32 seq = 3;
    required bytes state = 4;
    repeated int32 users = 5;
}

// API#0x55
// ResponseSeq
// Changing group title
// groupPeerGroup's peer
// titlenew group title
message RequestEditGroupTitle {
    required GroupOutPeer groupPeer = 1;
    required string title = 3;
}

// API#0x56
// ResponseAvatarChanged
// Changing group avatar
// groupPeerGroup's peer
// fileLocationuploaded file for avatar
message RequestEditGroupAvatar {
    required GroupOutPeer groupPeer = 1;
    required FileLocation fileLocation = 3;
}

// API#0x65
// ResponseSeq
// Removing group avatar
// groupPeerGroup's peer
message RequestRemoveGroupAvatar {
    required GroupOutPeer groupPeer = 1;
}

// API#0x45
// ResponseSeq
// Inviting users to group
// groupPeerGroup's peer
// usersUsers for invitation
message RequestInviteUsers {
    required GroupOutPeer groupPeer = 1;
    repeated UserOutPeer users = 3;
}

// API#0x46
// ResponseSeq
// Leaving group
// groupPeerGroup's peer
message RequestLeaveGroup {
    required GroupOutPeer groupPeer = 1;
}

// API#0x61
// ResponseSeq
// Leaving and deleting group (similar to DeleteChat)
// groupPeerGroup's peer
message RequestDeleteGroup {
    required GroupOutPeer groupPeer = 1;
}

// API#0x47
// ResponseSeq
// Removing users from group
// groupPeerGroup's peer
// usersusers for removing
message RequestRemoveUsers {
    required GroupOutPeer groupPeer = 1;
    repeated UserOutPeer users = 3;
}

// API#0x24
// Update about inviting current user to group
// groupId  Group Id
// inviteUid  Inviter UID. If equals to current uid than group created by user.
// date  Date of creating
message UpdateGroupInvite {
    required int32 groupId = 1;
    required int32 inviteUid = 5;
    required int64 date = 8;
}

// API#0x15
// Update about adding user to group
// groupId  Group Id
// uid  Added user ID
// inviterUid  Inviter user ID
// date  Date of adding user to group
message UpdateGroupUserAdded {
    required int32 groupId = 1;
    required int32 uid = 2;
    required int32 inviterUid = 3;
    required int64 date = 4;
}

// API#0x17
// Update about leaving user
// groupId  Group Id
// uid  User's ID
// date  Date of user leave
message UpdateGroupUserLeave {
    required int32 groupId = 1;
    required int32 uid = 2;
    required int64 date = 3;
}

// API#0x18
// Update about kicking user
// groupId  Group Id
// uid  Kicked user's ID
// kickerUid  Kicker user's ID
// date  Date of user kick
message UpdateGroupUserKick {
    required int32 groupId = 1;
    required int32 uid = 2;
    required int32 kickerUid = 3;
    required int64 date = 4;
}

// API#0x2C
// Silent group members update
// groupId  Group Id
// members  New members list
message UpdateGroupMembersUpdate {
    required int32 groupId = 1;
    repeated int32 members = 2;
}

// API#0x26
// Update about group title change
// groupId  Group Id
// uid  Changer UID
// title  New Title of group
// date  Date of title change
message UpdateGroupTitleChanged {
    required int32 groupId = 1;
    required int32 uid = 2;
    required string title = 3;
    required int64 date = 4;
}

// API#0x27
// Update about group avatar change
// groupId  Group Id
// uid  Avatar changer uid
// avatar  New Avatar. If null then avatar is removed
// date  Date of avatar change
message UpdateGroupAvatarChanged {
    required int32 groupId = 1;
    required int32 uid = 2;
    optional Avatar avatar = 3;
    required int64 date = 4;
}

//////////////////////////////////////////////////////
// Message and Dialogs lists
//////////////////////////////////////////////////////
//<h1>Overview</h1>
//Actor can work with encrypted and plain messages and encrypted messages does not appear in history,
//but it affects conversation lists.
//<h1>Messages ordering</h1>
//Server provide date in milliseconds for accurate ordering of incoming messages in applications. 
//NOTHING can move conversation on conversation list down on list. For example if you clean chat or delete top message
//for the conversation conversation keep its position. Some events doesn't move conversation to top
//of conversations list. For example leaving chat or new device notification doesn't move it up.
//<h1>Deleting of messages</h1>
//For deletion of messages either plain or encrypted there is method MessageDelete#0x62 deletion.
//Deletion of message is irreversible for now.
//<h1>Deleting and clearing of conversation</h1>
//Clearing of conversation deletes all messages in conversation and clears top message in conversation list.
//Deletion of conversation deletes all messages and removes conversation from conversations list.
//For sync this operations there are updates ChatDelete#0x30 and ChatClear#0x2F.
//Deletion by ChatDelete of group causes automatic group leaving.
//<h1>Loading history</h1>
//For loading conversation list use method LoadDialogs#0x68. 
//When top message in conversation is encrypted than dialog item will contain empty text. Dialog item contains
//two dates - visual and sort, visual used for displaying date and sort for sorting dialog in dialog list.
// 
//For loading history of conversation use method LoadHistory#0x68.
// 
//Loading initial list are called with zero startDate and after loading more messages 
//we will use maximum date from messages for startDate value.

// Message from history
// senderUid  Sender of mesasge
// rid  Random Id of message
// date  Date of message
// message  Content of message
message HistoryMessage {
    required int32 senderUid = 1;
    required int64 rid = 2;
    required int64 date = 3;
    required MessageContent message = 5;
}

// API#0x76
// ResponseLoadHistory
// Loading history of chat
// peerPeer of conversation
// startDatestart date of messages for loading or 0 for loading from start
// limitmaximum amount of messages (max is 100)
message RequestLoadHistory {
    required OutPeer peer = 1;
    required int64 startDate = 3;
    required int32 limit = 4;
}

// API#0x77
message ResponseLoadHistory {
    repeated HistoryMessage history = 1;
    repeated User users = 2;
}

// Conversation from history
// peer  Peer of conversation
// unreadCount  plain messages unread messages count
// sortDate  date of conversation for sorting
// senderUid  Sender of top message (may be zero)
// rid  Random ID of top message (may be zero)
// date  Date of top message (can't be zero)
// message  Content of message
message Dialog {
    required Peer peer = 1;
    required int32 unreadCount = 3;
    required int64 sortDate = 4;
    required int32 senderUid = 5;
    required int64 rid = 6;
    required int64 date = 7;
    required MessageContent message = 8;
}

// API#0x68
// ResponseLoadDialogs
// Loading conversation history
// startDatestart date of conversation loading
// limitlimit maximum amount of messages (max is 100)
message RequestLoadDialogs {
    required int64 startDate = 1;
    required int32 limit = 2;
}

// API#0x69
message ResponseLoadDialogs {
    repeated Group groups = 1;
    repeated User users = 2;
    repeated Dialog dialogs = 3;
}

//////////////////////////////////////////////////////
// Encryption
//////////////////////////////////////////////////////
//When user authenticates application send it's RSA public key for receiving encrypted messages.
//Each public key has keyHash that calculated on server side.
//Before sending encrypted messages application need to download all required receiver's and own
//public keys

// User public key reference
// uid  User ID
// keyHash  Public key hash
message UserKey {
    required int32 uid = 1;
    required int64 keyHash = 2;
}

// Public Key
// uid  Key's User Id
// keyHash  hash of user's key
// key  RSA Public Key in x.509 format
message PublicKey {
    required int32 uid = 1;
    required int64 keyHash = 2;
    required bytes key = 3;
}

// API#0x02
// Update about new public key of user
// uid  User's ID
// keyHash  Public key hash
// key  optional RSA Public Key in x.509 format
// date  Date of adding new key
message UpdateNewDevice {
    required int32 uid = 1;
    required int64 keyHash = 2;
    optional bytes key = 3;
    required int64 date = 4;
}

// API#0x25
// Update about removing public key of user
// uid  User's ID
// keyHash  Key Hash of removed key
message UpdateRemovedDevice {
    required int32 uid = 1;
    required int64 keyHash = 2;
}

// Request for download public key
// uid  uiser's ID
// accessHash  Access Hash of User
// keyHash  Public Key hash
message PublicKeyRequest {
    required int32 uid = 1;
    required int64 accessHash = 2;
    required int64 keyHash = 3;
}

// API#0x06
// ResponseGetPublicKeys
// Loading required publick keys
// keyskey requests
message RequestGetPublicKeys {
    repeated PublicKeyRequest keys = 1;
}

// API#0x18
message ResponseGetPublicKeys {
    repeated PublicKey keys = 1;
}

//////////////////////////////////////////////////////
// Typing and Online
//////////////////////////////////////////////////////

// API#0x1B
// ResponseVoid
// Sending typing notification
// peerDestination peer
// typingTypetyping type.
message RequestTyping {
    required OutPeer peer = 1;
    required int32 typingType = 3;
}

// API#0x1D
// ResponseVoid
// Sending online state
// isOnlineis user online
// timeouttimeout of online state
message RequestSetOnline {
    required bool isOnline = 1;
    required int64 timeout = 2;
}

// API#0x06
// Update about user's typing
// peer  Conversation peer
// uid  User's id
// typingType  Type of typing
message UpdateTyping {
    required Peer peer = 1;
    required int32 uid = 2;
    required int32 typingType = 3;
}

// API#0x07
// Update about user became online
// uid  User's Id
message UpdateUserOnline {
    required int32 uid = 1;
}

// API#0x08
// Update about user became offline
// uid  User's id
message UpdateUserOffline {
    required int32 uid = 1;
}

// API#0x09
// Update about user's last seen state
// uid  User's id
// time  Last seen time
message UpdateUserLastSeen {
    required int32 uid = 1;
    required int64 time = 2;
}

// API#0x21
// Update about group online change
// groupId  Group id
// count  current online user's count
message UpdateGroupOnline {
    required int32 groupId = 1;
    required int32 count = 2;
}

//////////////////////////////////////////////////////
// Media and Files
//////////////////////////////////////////////////////

// Location of file on server
// fileId  Unique Id of file
// accessHash  Access hash of file
message FileLocation {
    required int64 fileId = 1;
    required int64 accessHash = 2;
}

// Avatar Image
// fileLocation  Location of file
// width  Width of avatar image
// height  Height of avatar image
// fileSize  Size of file
message AvatarImage {
    required FileLocation fileLocation = 1;
    required int32 width = 2;
    required int32 height = 3;
    required int32 fileSize = 4;
}

// Avatar of User or Group
// smallImage  Optional small image of avatar box in 100x100
// largeImage  Optional large image of avatar box in 200x200
// fullImage  Optional full screen image of avatar
message Avatar {
    optional AvatarImage smallImage = 1;
    optional AvatarImage largeImage = 2;
    optional AvatarImage fullImage = 3;
}

// Fast thumb of media messages. Less than 90x90 and compressed by JPEG with low quality
// w  Width of thumb
// h  Height of thump
// thumb  compressed image data
message FastThumb {
    required int32 w = 1;
    required int32 h = 2;
    required bytes thumb = 3;
}

// API#0x10
// ResponseGetFile
// Downloading file part
// fileLocationlocation of file
// offsetoffset in file in bytes
// limitmaximum size of file part
message RequestGetFile {
    required FileLocation fileLocation = 1;
    required int32 offset = 2;
    required int32 limit = 3;
}

// API#0x11
message ResponseGetFile {
    required bytes payload = 1;
}

// Reference for upload session
// serverData  server related data for upload
message UploadConfig {
    required bytes serverData = 1;
}

// API#0x12
// ResponseStartUpload
// Starting file upload
message RequestStartUpload {
}

// API#0x13
message ResponseStartUpload {
    required UploadConfig config = 1;
}

// API#0x14
// ResponseVoid
// Uploading part of file
// blockIndexindex of block
// payloadblock payload
message RequestUploadPart {
    required UploadConfig config = 1;
    required int32 blockIndex = 2;
    required bytes payload = 3;
}

// API#0x16
// ResponseCompleteUpload
// Complete uploading
// configUpload configuration
// blocksCountblocks count
// crc32crc32 of uploaded file
message RequestCompleteUpload {
    required UploadConfig config = 1;
    required int32 blocksCount = 2;
    required int64 crc32 = 3;
}

// API#0x17
message ResponseCompleteUpload {
    required FileLocation location = 1;
}

//////////////////////////////////////////////////////
// Push
//////////////////////////////////////////////////////
//Vendor's pushes for receiving push notifications.
//Push notification contains current sequence number of main sequence.

// API#0x33
// ResponseVoid
// Registering push token on server
// projectIdProject Id of token
// tokentoken value
message RequestRegisterGooglePush {
    required int64 projectId = 1;
    required string token = 2;
}

// API#0x4C
// ResponseVoid
// Registering apple push on server
// apnsKeyapns key id
// tokentoken value
message RequestRegisterApplePush {
    required int32 apnsKey = 1;
    required string token = 2;
}

// API#0x34
// ResponseVoid
// Unregister push
message RequestUnregisterPush {
}

//////////////////////////////////////////////////////
// Peers
//////////////////////////////////////////////////////
//Peer is an identificator of specific conversation.

enum PeerType {
    PRIVATE = 1;
    GROUP = 2;
}

// Peer
// type  Peer Type
// id  Peer Id
message Peer {
    required PeerType type = 1;
    required int32 id = 2;
}

// Out peer with access hash
// type  Peer Type
// id  Peer Id
// accessHash  Peer access hash
message OutPeer {
    required PeerType type = 1;
    required int32 id = 2;
    required int64 accessHash = 3;
}

// User's out peer
// uid  User's id
// accessHash  User's access hash
message UserOutPeer {
    required int32 uid = 1;
    required int64 accessHash = 2;
}

// Group's out peer
// groupId  Group's Id
// accessHash  Group's access hash
message GroupOutPeer {
    required int32 groupId = 1;
    required int64 accessHash = 2;
}

//////////////////////////////////////////////////////
// Sequence and Updates
//////////////////////////////////////////////////////
//Each device has it's own update sequence. At the begining application request initial sequence state by
//calling GetState. On each application restart or NewSessionCreated application calls GetDifference for receiving
//updates in update sequence.
//GetState and GetDifference automatically subscribes session to receiving updates in session.
//Each update has seq and state. Seq is sequental index of updated and used for detecting of holes in update sequence
//(because of server failure or session die) on client side.
//All updates needed to be processed in partucular order according to seq values.
//In some updates there can be references to users that are not available at client yer. In this case application need
//to ignore such update and init getting difference.

// API#0x0D
// Sequence update
// seq  Sequence number of update
// state  Sequece state of update
// updateHeader  header of update
// update  The update
message UpdateSeqUpdate {
    required int32 seq = 1;
    required bytes state = 2;
    required int32 updateHeader = 3;
    required bytes update = 4;
}

// API#0x49
// Fat sequence update with additional data
// seq  Sequence number of update
// state  Sequence state of update
// updateHeader  header of update
// update  The update
// users  Users that are referenced in update 
// groups  Groups that are referenced in update
message UpdateFatSeqUpdate {
    required int32 seq = 1;
    required bytes state = 2;
    required int32 updateHeader = 3;
    required bytes update = 4;
    repeated User users = 5;
    repeated Group groups = 6;
}

// API#0x1A
// Out of sequence update (for typing and online statuses)
// date  Date of update
// updateHeader  Header of update
// update  The update
message UpdateWeakUpdate {
    required int64 date = 1;
    required int32 updateHeader = 2;
    required bytes update = 3;
}

// API#0x19
// Notification about requiring performing manual GetDifference
message UpdateSeqUpdateTooLong {
}

// API#0x09
// ResponseSeq
// Get main sequence state
message RequestGetState {
}

// Update from GetDifference
// updateHeader  Header of update
// update  The update
message DifferenceUpdate {
    required int32 updateHeader = 1;
    required bytes update = 2;
}

// API#0x0B
// ResponseGetDifference
// Getting difference of sequence
message RequestGetDifference {
    required int32 seq = 1;
    required bytes state = 2;
}

// API#0x0C
message ResponseGetDifference {
    required int32 seq = 1;
    required bytes state = 2;
    repeated User users = 3;
    repeated Group groups = 6;
    repeated DifferenceUpdate updates = 4;
    required bool needMode = 5;
}

// API#0x20
// ResponseVoid
// Subscribing for users online
// usersUsers for subscription
message RequestSubscribeToOnline {
    repeated UserOutPeer users = 1;
}

// API#0x21
// ResponseVoid
// Removing subscription for users online
// usersUsers of subscriptions
message RequestSubscribeFromOnline {
    repeated UserOutPeer users = 1;
}

// API#0x4A
// ResponseVoid
// Subscribing for groups online
// groupsGroups for subscription
message RequestSubscribeToGroupOnline {
    repeated GroupOutPeer groups = 1;
}

// API#0x4B
// ResponseVoid
// Removing subscription for groups online
// groupsGroups of subscriptions
message RequestSubscribeFromGroupOnline {
    repeated GroupOutPeer groups = 1;
}

//////////////////////////////////////////////////////
// Miscellaneous
//////////////////////////////////////////////////////

// API#0x32
// Empty response
message ResponseVoid {
}

// API#0x48
// Sequence response. Methods that return this value must process response in particular order
// seq  Sequence number of response
// state  Sequence state of response
message ResponseSeq {
    required int32 seq = 1;
    required bytes state = 2;
}

// API#0x44
// Response of Group or Profile avatar change
// avatar  new avatar
// seq  Sequence number of response
// state  Sequence state of response
message ResponseAvatarChanged {
    required Avatar avatar = 1;
    required int32 seq = 2;
    required bytes state = 3;
}

// Configuration of system
// maxGroupSize  Current maximum group size
message Config {
    required int32 maxGroupSize = 1;
}

// API#0x2A
// Update about config change
// config  new config
message UpdateConfig {
    required Config config = 1;
}

