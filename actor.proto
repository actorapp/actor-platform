//////////////////////////////////////////////////////
// Authentication
//////////////////////////////////////////////////////
//<p>Actor now support only one way for authentication - by SMS or phone call.</p>
//<p>Authorization steps:
//<ol>
//<li>Request SMS Code by calling RequestAuthCode</li>
//<li>If SMS arrives than send Authorization code in SignIn/SignUp</li>
//<li>If sms doesn't arrive for a long time - request phone activation by
//calling AuthCodeCall</li>
//</ol>
//</p>
//Some rules<br/>
//If RequestAuthCode return isRegistered = false than use SignUp method else SignIn.<br/>
//If on any step API return PHONE_CODE_EXPIRED than application MUST start
//authorization process from begining.<br/>

// API#0x01
// ResponseSendAuthCode
// Sending SMS with activation code
// phoneNumber Phone number in international format
// appId Application ID
// apiKey Application API key
// Sending SMS with activation code
// phoneNumber Phone number in international format
// appId Application ID
// apiKey Application API key
message RequestSendAuthCode {
    required int64 phoneNumber = 1;
    required int32 appId = 2;
    required string apiKey = 3;
}

// API#0x02
message ResponseSendAuthCode {
    required string smsHash = 1;
    required bool isRegistered = 2;
}

// API#0x5A
// ResponseVoid
// Requesting Phone activation
// phoneNumber Phone number in international format
// smsHash Code request hash from RequestAuthCode
// appId Application ID
// apiKey Application API key
message RequestSendAuthCall {
    required int64 phoneNumber = 1;
    required string smsHash = 2;
    required int32 appId = 3;
    required string apiKey = 4;
}

// API#0x05
// Authentication result
// publicKeyHash Public Key Hash of current authentication
// user The authenticated User
// config Current config of server
message ResponseAuth {
    required int64 publicKeyHash = 1;
    required User user = 2;
    required Config config = 3;
}

// API#0x03
// ResponseAuth
// Performing user signin
// phoneNumber Phone number in international format
// smsHash Code request hash from RequestAuthCode
// smsCode Confirmation code from SMS
// deviceHash Hash of device unique id and app bundle id. Used for autologout users when app is reinstalled
// deviceTitle Device title like 'Steven's iPhone'
// appId Application ID
// appKey Application API key
message RequestSignIn {
    required int64 phoneNumber = 1;
    required string smsHash = 2;
    required string smsCode = 3;
    required bytes deviceHash = 5;
    required string deviceTitle = 6;
    required int32 appId = 7;
    required string appKey = 8;
}

// API#0x04
// ResponseAuth
// Performing user signup. If user perform signup on already registered user it just override previous
// profile information
// phoneNumber Phone number in international format
// smsHash Code request hash from RequestAuthCode
// smsCode Confirmation code from SMS
// name User name
// deviceHash Hash of device unique id and app bundle id. Used for autologout users when app is reinstalled
// deviceTitle Device title like 'Steven's iPhone'
// appId Application ID
// appKey pplication API key
message RequestSignUp {
    required int64 phoneNumber = 1;
    required string smsHash = 2;
    required string smsCode = 3;
    required string name = 4;
    required bytes deviceHash = 7;
    required string deviceTitle = 8;
    required int32 appId = 9;
    required string appKey = 10;
    required bool isSilent = 11;
}

// Authentication session
// id Unuque ID of session
// authHolder holder of session. 0 - this device, 1 - other.
// appId Application Id (user in SignIn/SignUp)
// appTitle Title of application
// deviceTitle Title of device
// authTime Time of session creating
// authLocation two-letter country code of session create
// latitude optional latitude of auth if available
// longitude optional longitude of auth if available
message AuthSession {
    required int32 id = 1;
    required AuthHolder authHolder = 2;
    required int32 appId = 3;
    required string appTitle = 4;
    required string deviceTitle = 5;
    required int32 authTime = 6;
    required string authLocation = 7;
    optional double latitude = 8;
    optional double longitude = 9;
}

enum AuthHolder {
    THISDEVICE = 1;
    OTHERDEVICE = 2;
}

// API#0x50
// ResponseGetAuthSessions
// Getting of all active user's authentication sessions
message RequestGetAuthSessions {
}

// API#0x51
message ResponseGetAuthSessions {
    repeated AuthSession userAuths = 1;
}

// API#0x52
// ResponseVoid
// SignOut on specified user's session
// id id from AuthItem
message RequestTerminateSession {
    required int32 id = 1;
}

// API#0x53
// ResponseVoid
// SignOut on all exept current sessions
message RequestTerminateAllSessions {
}

// API#0x54
// ResponseVoid
// SignOut current session
message RequestSignOut {
}

//////////////////////////////////////////////////////
// Users
//////////////////////////////////////////////////////
//Users are objects that secured by accessHash. You can't load user profile by it's id.
//You can't send message to user without finding it's object in Updates or by calling
//method for user search, contacts import or some other methods.
//
//Applications need to keep all Users information forever.
//
//Each User have optional localName - name of user that was set by current user and can be changed
//any time by calling EditUserLocalName method.

enum Sex {
    UNKNOWN = 1;
    MALE = 2;
    FEMALE = 3;
}

enum UserState {
    REGISTERED = 1;
    EMAIL = 2;
    DELETED = 3;
}

// Extendend phone information
// id Phone id
// accessHash Access hash of phone number
// phone Phone number in international format
// phoneTitle Title of phone
message Phone {
    required int32 id = 1;
    required int64 accessHash = 2;
    required int64 phone = 3;
    required string phoneTitle = 4;
}

// Extendend email information
// id Email id
// accessHash Access hash of email
// email Email
// emailTitle Descruption of email
message Email {
    required int32 id = 1;
    required int64 accessHash = 2;
    required string email = 3;
    required string emailTitle = 4;
}

// Main user object
// id uid
// accessHash user's access hash
// name user's name
// localName user's local name
// sex optional sex of user
// keyHashes key hashes of user
// phone [DEPRECATED] Phone number of user
// avatar avatar of user
// phones phones of user
// emails emails of user
message User {
    required int32 id = 1;
    required int64 accessHash = 2;
    required string name = 3;
    optional string localName = 4;
    optional Sex sex = 5;
    repeated int64 keyHashes = 6;
    required int64 phone = 7;
    optional Avatar avatar = 8;
    repeated int32 phones = 9;
    repeated int32 emails = 10;
    required UserState userState = 11;
}

// API#0x60
// ResponseSeq
// Renaming of user's visible name
// uid target User's uid
// accessHash User's accessHash
// name New user name
message RequestEditUserLocalName {
    required int32 uid = 1;
    required int64 accessHash = 2;
    required string name = 3;
}

// API#0x10
// Update about avatar changed
// uid user's uid
// avatar user's new avatar
message UpdateUserAvatarChanged {
    required int32 uid = 1;
    optional Avatar avatar = 2;
}

// API#0x20
// Update about name changed
// uid user's uid
// name user's name
message UpdateUserNameChanged {
    required int32 uid = 1;
    required string name = 2;
}

// API#0x33
// Update about local name changed
// uid user's uid
// localName new user's local name
message UpdateUserLocalNameChanged {
    required int32 uid = 1;
    optional string localName = 2;
}

// API#0x57
// Update about phone added to user
// uid user's id
// phoneId added phone id
message UpdateUserPhoneAdded {
    required int32 uid = 1;
    required int32 phoneId = 2;
}

// API#0x58
// Update about phone removed from user
// uid user's id
// phoneId removed phone id
message UpdateUserPhoneRemoved {
    required int32 uid = 1;
    required int32 phoneId = 2;
}

// API#0x59
// Update about phone title changed
// phoneId phone number
// title new title for phone
message UpdatePhoneTitleChanged {
    required int32 phoneId = 2;
    required string title = 3;
}

// API#0x65
// Update about phone move
// phoneId Phone number id
// uid new uid for phone
message UpdatePhoneMoved {
    required int32 phoneId = 1;
    required int32 uid = 2;
}

// API#0x60
// Update about email added to user
// uid user's id
// emailId added email id
message UpdateUserEmailAdded {
    required int32 uid = 1;
    required int32 emailId = 2;
}

// API#0x61
// Update about email removed from user
// uid user's id
// emailId removed email id
message UpdateUserEmailRemoved {
    required int32 uid = 1;
    required int32 emailId = 2;
}

// API#0x62
// Update about email title changed
// emailId email id
// title new title for email
message UpdateEmailTitleChanged {
    required int32 emailId = 1;
    required string title = 2;
}

// API#0x66
// Update about email move from one user to another
// emailId Email id
// uid new uid for email
message UpdateEmailMoved {
    required int32 emailId = 1;
    required int32 uid = 2;
}

// API#0x56
// Update about contact information change
// uid user's uid
// phones new phones list
// emails new emails list
message UpdateUserContactsChanged {
    required int32 uid = 1;
    repeated int32 phones = 2;
    repeated int32 emails = 3;
}

// API#0x64
// Update about user state changed
// uid user's id
// state new user state
message UpdateUserStateChanged {
    required int32 uid = 1;
    required UserState state = 2;
}

//////////////////////////////////////////////////////
// Profile
//////////////////////////////////////////////////////

// API#0x35
// ResponseSeq
// Changing account's name
// name New name
message RequestEditName {
    required string name = 1;
}

// API#0x1F
// ResponseEditAvatar
// Changing account's avatar
// fileLocation File Location of uploaded unencrypted avatar
message RequestEditAvatar {
    required FileLocation fileLocation = 1;
}

// API#0x67
message ResponseEditAvatar {
    required Avatar avatar = 1;
    required int32 seq = 2;
    required bytes state = 3;
}

// API#0x5B
// ResponseSeq
// Removing account's avatar
message RequestRemoveAvatar {
}

// API#0x78
// ResponseVoid
// Sending activation code to email
// email Email for attaching to account
// Sending activation code to email
// email Email for adding
// description Optional description for email
message RequestSendEmailCode {
    required string email = 1;
    optional string description = 2;
}

// API#0x7B
// ResponseSeq
// Detaching email from account
// email Detaching email
// accessHash Access hash of email
message RequestDetachEmail {
    required int32 email = 1;
    required int64 accessHash = 2;
}

// API#0x7C
// ResponseSeq
// Change phone description
// phoneId Phone number id
// title New phone title
message RequestChangePhoneTitle {
    required int32 phoneId = 1;
    required string title = 2;
}

// API#0x7D
// ResponseSeq
// Change email description
// emailId Email id
// title New email title
message RequestChangeEmailTitle {
    required int32 emailId = 1;
    required string title = 2;
}

//////////////////////////////////////////////////////
// Contacts
//////////////////////////////////////////////////////
//Before working with contact list is is useful to import contacts from phone first by calling
//method ImportContacts#0x07.
//
//All phone numbers MUST be preprocessed before import by some library (like libphonenumber)
//and build international phone number depending on current users phone and/or locale.
//
//For loading contact list from server use GetContacts#0x57.
//If during this call there are some updates about contact list change
//it is recommended to call it again. Also applications need to sync contacts on application start.
//
//For searching for users without adding to contacts list use method FindContacts#0x70.
//
//For adding/deleting contacts AddContact#0x72 and DeleteContact#0x59.

// Phone for import
// phoneNumber phone number for import in international format
// name optional name for contact
message PhoneToImport {
    required int64 phoneNumber = 1;
    optional string name = 2;
}

// Email for import
// email email for importing
// name optional name for contact
message EmailToImport {
    required string email = 1;
    optional string name = 2;
}

// API#0x07
// ResponseImportContacts
// Importing phones and emails for building contact list
// Maximum amount of items for import per method call equals to 100.
// phones Phones for import
// emails Emails for import
message RequestImportContacts {
    repeated PhoneToImport phones = 1;
    repeated EmailToImport emails = 2;
}

// API#0x08
message ResponseImportContacts {
    repeated User users = 1;
    required int32 seq = 2;
    required bytes state = 3;
}

// API#0x57
// ResponseGetContacts
// Getting current contact list
// SHA256 hash of list of a comma-separated list of contact UIDs in ascending
// order may be passed in contactsHash parameter.
// If the contact list was not changed, isNotChanged will be true.
// contactsHash Hash of saved list in application
message RequestGetContacts {
    required string contactsHash = 1;
}

// API#0x58
message ResponseGetContacts {
    repeated User users = 1;
    required bool isNotChanged = 2;
}

// API#0x59
// ResponseSeq
// Removing contact from contact list
// uid Contact's UID
// accessHash Contact's AccessHash
message RequestRemoveContact {
    required int32 uid = 1;
    required int64 accessHash = 2;
}

// API#0x72
// ResponseSeq
// Adding contact to contact list
// uid Contact's UID
// accessHash Contact's AccessHash
message RequestAddContact {
    required int32 uid = 1;
    required int64 accessHash = 2;
}

// API#0x70
// ResponseSearchContacts
// Searching contacts by user's query
// request Search query
message RequestSearchContacts {
    required string request = 1;
}

// API#0x71
message ResponseSearchContacts {
    repeated User users = 1;
}

// API#0x05
// Update about contact registration
// uid contact's uid
// isSilent is registration silent. If this value is true then don't show notification about registration
// date date of registration
message UpdateContactRegistered {
    required int32 uid = 1;
    required bool isSilent = 2;
    required int64 date = 3;
}

// API#0x28
// Update about contacts added
// uids added contacts
message UpdateContactsAdded {
    repeated int32 uids = 1;
}

// API#0x29
// Update about contacts removed
// uids removed contacts
message UpdateContactsRemoved {
    repeated int32 uids = 1;
}

//////////////////////////////////////////////////////
// Messaging
//////////////////////////////////////////////////////
//Actor can work with encrypted and plain messages in one conversation. For both types of messages API
//contains a bit different methods. Also encrypted and plain messages have different schemes.
//<h3>Messages</h3>
//Message entity contains:
//<ul>
//<li>PeerType - group chat or private</li>
//<li>PeerId - group or user id of conversation</li>
//<li>RandomId - unique id of message that generated by sender. In Encrypted messages random id is encrypted.</li>
//<li>Date - date of message (calculated on server)</li>
//<li>Content</li>
//</ul>
//<h3>Message content</h3>
//Message can be one of three basic types of messages: Text Message, File Message and Service message.
//All messages can contain extensions. For example we can send text message and add markdown extension with
//formatted text in markdown and clients that support this extension will show markdown, and that clients that
//not supported extension then show simple text. File messages can have photo, video or voice extensions.
//Service message can have extensions extensions such as "user added", "group created", "avatar changed", etc.
//<h3>Send messages</h3>
//Sending messages looks same for encrypted and plain messages. Client MUST prepare all required data
//before sending message (for example FastThumb for photo/video/documents) and call required methods.
//Encrypted messages differs here only by a little different scheme and encryption.
//<h3>WRONG_KEYS and incorrect keys</h3>
//For sending encrypted messages client MUST send messages encrypted for all own and receivers keys.
//If client send encryption with missing, old or incorrect keys it will receive WRONG_KEYS.
//In WRONG_KEYS you need to deserialize relatedData from RpcError to WrongKeysErrorData
//and get detailed information about keys. Sometimes there are some broken keys on server and client can't
//encrypt messages with it than client MUST send empty encrypted key in request elsewhere API return WRONG_KEYS.
//<h3>Encrypted messages and New Devices</h3>
//When you send message to someone and when he registered with new device there are no way to receive old encrypted
//messages on new device and because of this there are a problem about read/delivery statuses.
//Alice send messages to Bob, but Bob lose his device and  buy new iPhone and installed Actor.
//Alice receive notification about new device and send another message. Bob open chat with Alice and
//send read status with maximum message read date. Alice will mark all sent messages as read and one that
//was not delivered. We can use status notifications per message, but in VERY heavy conversations it will be
//a lot of unnecessary traffic. For resolving this small issue we have different ways of message statuses
//for encrypted and plain messages. Also it is recomended to mark all undelivered messages on new device update as
//not devered with warring sign.
//<h3>Message Read and Delivery</h3>
//There are two different ways for read and delivery statuses for encrypted and plain messages.
//For encrypted messages used status change by RandomId and for plain messages used by maximum
//date of read/delivered message.

// Text message
// text the text
// extType type of extension. Now there are no extensions.
// ext Optional bytes of extension
message TextMessage {
    required string text = 1;
    required int32 extType = 2;
    optional bytes ext = 3;
}

// Service message
// text service message text
// extType extension type. 0x01 => ServiceExUserAdded, 0x02 => ServiceExUserKicked, 0x03 => ServiveExUserLeft, 0x04 => ServiceExGroupCreated, 0x05 => ServiceExGroupChangedTitle, 0x06 => ServiceExGroupChangedAvatar
// ext Extension
message ServiceMessage {
    required string text = 1;
    required int32 extType = 2;
    optional bytes ext = 3;
}

// Service message about adding user to group
// addedUid added user id
message ServiceExUserAdded {
    required int32 addedUid = 1;
}

// Service message about kicking user from group
// kickedUid kicked user id
message ServiceExUserKicked {
    required int32 kickedUid = 1;
}

// Service message about user left group
message ServiceExUserLeft {
}

// Service message about group creating
message ServiceExGroupCreated {
}

// Service message about group title change
// title New group title
message ServiceExChangedTitle {
    required string title = 1;
}

// Service message about avatar change
// avatar Updated avatar
message ServiceExChangedAvatar {
    optional Avatar avatar = 1;
}

// Service message about email user registration
// uid User id
message ServiceExEmailContactRegistered {
    required int32 uid = 1;
}

// File message
// fileId file id
// accessHash file access hash
// fileSize file size
// name name of file
// mimeType mimetype of file
// thumb optional thumb of file. JPEG less that 90x90 with 60-70 quality.
// extType Extension type
// ext Extension
message DocumentMessage {
    required int64 fileId = 1;
    required int64 accessHash = 2;
    required int32 fileSize = 3;
    optional EncryptionType encryptionType = 9;
    optional bytes encryptionKey = 10;
    optional int32 plainFileSize = 11;
    required string name = 4;
    required string mimeType = 5;
    optional FastThumb thumb = 6;
    required int32 extType = 7;
    optional bytes ext = 8;
}

// File photo extension
// w image width
// h image height
message DocumentExPhoto {
    required int32 w = 1;
    required int32 h = 2;
}

// File video extension
// w video width
// h video height
// duration video duration
message DocumentExVideo {
    required int32 w = 1;
    required int32 h = 2;
    required int32 duration = 3;
}

// File voice extension
// duration voice duration
message DocumentExVoice {
    required int32 duration = 1;
}

// Encrypted AES key for encrypted messages
// keyHash hash of public key of encrypted aes key
// aesEncryptedKey encrypted aes key
message EncryptedAesKey {
    required int64 keyHash = 1;
    required bytes aesEncryptedKey = 2;
}

// API#0x0E
// ResponseSeqDate
// Sending encrypted message
// peer Destination peer for message
// rid Message random id (generated on client side)
// encryptedMessage message encrypted by random aes key
// keys encrypted aes keys for receivers devices
// ownKeys encrypted aes keys for own devices
message RequestSendEncryptedMessage {
    required OutPeer peer = 1;
    required int64 rid = 3;
    required bytes encryptedMessage = 4;
    repeated EncryptedAesKey keys = 5;
    repeated EncryptedAesKey ownKeys = 6;
}

// API#0x5C
// ResponseSeqDate
// Sending plain message
// peer Destination peer for message (now supported only user's peer)
// rid Message random id (generated on clien side)
// message The message
message RequestSendMessage {
    required OutPeer peer = 1;
    required int64 rid = 3;
    required bytes message = 4;
}

// API#0x74
// ResponseVoid
// Confirmation of encrypted message receive by device
// peer Destination peer
// rid Message random id
message RequestEncryptedReceived {
    required OutPeer peer = 1;
    required int64 rid = 3;
}

// API#0x75
// ResponseVoid
// Marking encrypted message as read
// peer Destination peer
// rid Message random id
message RequestEncryptedRead {
    required OutPeer peer = 1;
    required int64 rid = 3;
}

// API#0x37
// ResponseVoid
// Confirmation of plain message receive by device
// peer Destination peer
// date Maximum date of received messages
message RequestMessageReceived {
    required OutPeer peer = 1;
    required int64 date = 3;
}

// API#0x39
// ResponseVoid
// Marking plain messages as read
// peer Destination peer
// date Maximum date of read messages
message RequestMessageRead {
    required OutPeer peer = 1;
    required int64 date = 3;
}

// API#0x62
// ResponseSeq
// Deleting messages
// peer Destination peer
// rids Message random id
message RequestDeleteMessage {
    required OutPeer peer = 1;
    repeated int64 rids = 3;
}

// API#0x63
// ResponseSeq
// Clearing of conversation (without removing dialog from dialogs list)
// peer Conversation peer
message RequestClearChat {
    required OutPeer peer = 1;
}

// API#0x64
// ResponseSeq
// Deleting of conversation (also leave group for group conversations)
// peer Conversation peer
message RequestDeleteChat {
    required OutPeer peer = 1;
}

// API#0x37
// Update about plain message
// peer Destination peer
// senderUid Sender of message
// date date of message
// rid Rid of message
// message message content
message UpdateMessage {
    required Peer peer = 1;
    required int32 senderUid = 2;
    required int64 date = 3;
    required int64 rid = 4;
    required bytes message = 5;
}

// API#0x04
// Update about message sent
// peer Destination peer
// rid Rid of message
// date Date of message
message UpdateMessageSent {
    required Peer peer = 1;
    required int64 rid = 2;
    required int64 date = 3;
}

// API#0x36
// Update about message received
// peer Destination peer
// startDate Start date of received message
// receivedDate Date of receive
message UpdateMessageReceived {
    required Peer peer = 1;
    required int64 startDate = 2;
    required int64 receivedDate = 3;
}

// API#0x13
// Update about message read
// peer Destination peer
// startDate Start date of read message
// readDate Date of read
message UpdateMessageRead {
    required Peer peer = 1;
    required int64 startDate = 2;
    required int64 readDate = 3;
}

// API#0x32
// Update about message read by me
// peer Destination peer
// startDate Start date of read message
message UpdateMessageReadByMe {
    required Peer peer = 1;
    required int64 startDate = 2;
}

// API#0x2E
// Update about message delete
// peer Destination peer
// rids Deleted messages
message UpdateMessageDelete {
    required Peer peer = 1;
    repeated int64 rids = 2;
}

// API#0x2F
// Update about chat clear
// peer Destination peer
message UpdateChatClear {
    required Peer peer = 1;
}

// API#0x30
// Update about chat delete
// peer Destination peer
message UpdateChatDelete {
    required Peer peer = 1;
}

//////////////////////////////////////////////////////
// Groups
//////////////////////////////////////////////////////

// Group information
// id group id
// accessHash Access hash of group
// title Title of group
// avatar Avatar of group
// isMember is member of group
// creatorUid Group creator
// members Members of group
// createDate Date of creation
message Group {
    required int32 id = 1;
    required int64 accessHash = 2;
    required string title = 3;
    optional Avatar avatar = 4;
    required bool isMember = 6;
    required int32 creatorUid = 8;
    repeated Member members = 9;
    required int64 createDate = 10;
}

// Member information
// uid User id
// inviterUid User inviter id
// date Adding date
message Member {
    required int32 uid = 1;
    required int32 inviterUid = 2;
    required int64 date = 3;
}

// API#0x41
// ResponseCreateGroup
// Creating group chat
// rid Random Id for avoiding double create
// title Group title
// users Members of group
// title Title of new group
// users Members of new group
message RequestCreateGroup {
    required int64 rid = 1;
    required string title = 2;
    repeated UserOutPeer users = 3;
}

// API#0x42
message ResponseCreateGroup {
    required GroupOutPeer groupPeer = 1;
    required int32 seq = 3;
    required bytes state = 4;
    repeated int32 users = 5;
    required int64 date = 6;
}

// API#0x55
// ResponseSeqDate
// Changing group title
// groupPeer Group's peer
// title new group title
// rid Random Id of operation
message RequestEditGroupTitle {
    required GroupOutPeer groupPeer = 1;
    required int64 rid = 4;
    required string title = 3;
}

// API#0x56
// ResponseEditGroupAvatar
// Changing group avatar
// groupPeer Group's peer
// fileLocation uploaded file for avatar
// rid Random Id of operation
message RequestEditGroupAvatar {
    required GroupOutPeer groupPeer = 1;
    required int64 rid = 4;
    required FileLocation fileLocation = 3;
}

// API#0x73
message ResponseEditGroupAvatar {
    required Avatar avatar = 1;
    required int32 seq = 2;
    required bytes state = 3;
    required int64 date = 4;
}

// API#0x65
// ResponseSeqDate
// Removing group avatar
// groupPeer Group's peer
// rid Random Id of operation
message RequestRemoveGroupAvatar {
    required GroupOutPeer groupPeer = 1;
    required int64 rid = 4;
}

// API#0x45
// ResponseSeqDate
// Inviting user to group
// groupPeer Group's peer
// user Users for invitation
// rid Random Id of operation
message RequestInviteUser {
    required GroupOutPeer groupPeer = 1;
    required int64 rid = 4;
    required UserOutPeer user = 3;
}

// API#0x46
// ResponseSeqDate
// Leaving group
// groupPeer Group's peer
// rid Random Id of operation
message RequestLeaveGroup {
    required GroupOutPeer groupPeer = 1;
    required int64 rid = 2;
}

// API#0x47
// ResponseSeqDate
// Kicking user from group
// groupPeer Group's peer
// user users for removing
// rid Random Id of operation
message RequestKickUser {
    required GroupOutPeer groupPeer = 1;
    required int64 rid = 4;
    required UserOutPeer user = 3;
}

// API#0x24
// Update about inviting current user to group
// groupId Group Id
// inviteUid Inviter UID. If equals to current uid than group created by user.
// date Date of creating
// rid Random Id of operation
message UpdateGroupInvite {
    required int32 groupId = 1;
    required int64 rid = 9;
    required int32 inviteUid = 5;
    required int64 date = 8;
}

// API#0x15
// Update about adding user to group
// groupId Group Id
// uid Added user ID
// inviterUid Inviter user ID
// date Date of adding user to group
// rid Random Id of operation
message UpdateGroupUserAdded {
    required int32 groupId = 1;
    required int64 rid = 5;
    required int32 uid = 2;
    required int32 inviterUid = 3;
    required int64 date = 4;
}

// API#0x17
// Update about leaving user
// groupId Group Id
// uid User's ID
// date Date of user leave
// rid Random Id of operation
message UpdateGroupUserLeave {
    required int32 groupId = 1;
    required int64 rid = 4;
    required int32 uid = 2;
    required int64 date = 3;
}

// API#0x18
// Update about kicking user
// groupId Group Id
// uid Kicked user's ID
// kickerUid Kicker user's ID
// date Date of user kick
// rid Random Id of operation
message UpdateGroupUserKick {
    required int32 groupId = 1;
    required int64 rid = 5;
    required int32 uid = 2;
    required int32 kickerUid = 3;
    required int64 date = 4;
}

// API#0x2C
// Silent group members update
// groupId Group Id
// members New members list
message UpdateGroupMembersUpdate {
    required int32 groupId = 1;
    repeated Member members = 2;
}

// API#0x26
// Update about group title change
// groupId Group Id
// uid Changer UID
// title New Title of group
// date Date of title change
// rid Random Id of operation
message UpdateGroupTitleChanged {
    required int32 groupId = 1;
    required int64 rid = 5;
    required int32 uid = 2;
    required string title = 3;
    required int64 date = 4;
}

// API#0x27
// Update about group avatar change
// groupId Group Id
// uid Avatar changer uid
// avatar New Avatar. If null then avatar is removed
// date Date of avatar change
// rid Random Id of operation
message UpdateGroupAvatarChanged {
    required int32 groupId = 1;
    required int64 rid = 5;
    required int32 uid = 2;
    optional Avatar avatar = 3;
    required int64 date = 4;
}

//////////////////////////////////////////////////////
// History
//////////////////////////////////////////////////////
//<h1>Overview</h1>
//Actor can work with encrypted and plain messages and encrypted messages does not appear in history,
//but it affects conversation lists.
//<h1>Messages ordering</h1>
//Server provide date in milliseconds for accurate ordering of incoming messages in applications.
//NOTHING can move conversation on conversation list down on list. For example if you clean chat or delete top message
//for the conversation conversation keep its position. Some events doesn't move conversation to top
//of conversations list. For example leaving chat or new device notification doesn't move it up.
//<h1>Deleting of messages</h1>
//For deletion of messages either plain or encrypted there is method MessageDelete#0x62 deletion.
//Deletion of message is irreversible for now.
//<h1>Deleting and clearing of conversation</h1>
//Clearing of conversation deletes all messages in conversation and clears top message in conversation list.
//Deletion of conversation deletes all messages and removes conversation from conversations list.
//For sync this operations there are updates ChatDelete#0x30 and ChatClear#0x2F.
//Deletion by ChatDelete of group causes automatic group leaving.
//<h1>Loading history</h1>
//For loading conversation list use method LoadDialogs#0x68.
//When top message in conversation is encrypted than dialog item will contain empty text. Dialog item contains
//two dates - visual and sort, visual used for displaying date and sort for sorting dialog in dialog list.
//
//For loading history of conversation use method LoadHistory#0x68.
//
//Loading initial list are called with zero startDate and after loading more messages
//we will use maximum date from messages for startDate value.

enum MessageState {
    SENT = 1;
    RECEIVED = 2;
    READ = 3;
}

// Message from history
// senderUid Sender of mesasge
// rid Random Id of message
// date Date of message
// message Content of message
message HistoryMessage {
    required int32 senderUid = 1;
    required int64 rid = 2;
    required int64 date = 3;
    required bytes message = 5;
    optional MessageState state = 6;
}

// API#0x76
// ResponseLoadHistory
// Loading history of chat
// peer Peer of conversation
// minDate start date of messages for loading or 0 for loading from start
// limit maximum amount of messages (max is 100)
message RequestLoadHistory {
    required OutPeer peer = 1;
    required int64 minDate = 3;
    required int32 limit = 4;
}

// API#0x77
message ResponseLoadHistory {
    repeated HistoryMessage history = 1;
    repeated User users = 2;
}

// Conversation from history
// peer Peer of conversation
// unreadCount plain messages unread messages count
// sortDate date of conversation for sorting
// senderUid Sender of top message (may be zero)
// rid Random ID of top message (may be zero)
// date Date of top message (can't be zero)
// message Content of message
message Dialog {
    required Peer peer = 1;
    required int32 unreadCount = 3;
    required int64 sortDate = 4;
    required int32 senderUid = 5;
    required int64 rid = 6;
    required int64 date = 7;
    required bytes message = 8;
    optional MessageState state = 9;
}

// API#0x68
// ResponseLoadDialogs
// Loading conversation history
// minDate start date of conversation loading. Use 0 to load latest messages
// limit limit maximum amount of messages (max is 100)
message RequestLoadDialogs {
    required int64 minDate = 1;
    required int32 limit = 2;
}

// API#0x69
message ResponseLoadDialogs {
    repeated Group groups = 1;
    repeated User users = 2;
    repeated Dialog dialogs = 3;
}

//////////////////////////////////////////////////////
// Typing and Online
//////////////////////////////////////////////////////

enum TypingType {
    TEXT = 0;
}

// API#0x1B
// ResponseVoid
// Sending typing notification
// peer Destination peer
// typingType typing type.
message RequestTyping {
    required OutPeer peer = 1;
    required TypingType typingType = 3;
}

// API#0x1D
// ResponseVoid
// Sending online state
// isOnline is user online
// timeout timeout of online state
message RequestSetOnline {
    required bool isOnline = 1;
    required int64 timeout = 2;
}

// API#0x06
// Update about user's typing
// peer Conversation peer
// uid User's id
// typingType Type of typing
message UpdateTyping {
    required Peer peer = 1;
    required int32 uid = 2;
    required TypingType typingType = 3;
}

// API#0x07
// Update about user became online
// uid User's Id
message UpdateUserOnline {
    required int32 uid = 1;
}

// API#0x08
// Update about user became offline
// uid User's id
message UpdateUserOffline {
    required int32 uid = 1;
}

// API#0x09
// Update about user's last seen state
// uid User's id
// date Last seen time
message UpdateUserLastSeen {
    required int32 uid = 1;
    required int64 date = 2;
}

// API#0x21
// Update about group online change
// groupId Group id
// count current online user's count
message UpdateGroupOnline {
    required int32 groupId = 1;
    required int32 count = 2;
}

//////////////////////////////////////////////////////
// Media and Files
//////////////////////////////////////////////////////

enum EncryptionType {
    NONE = 0;
    AES = 1;
    AES_THEN_MAC = 2;
}

// Location of file on server
// fileId Unique Id of file
// accessHash Access hash of file
message FileLocation {
    required int64 fileId = 1;
    required int64 accessHash = 2;
}

// Avatar Image
// fileLocation Location of file
// width Width of avatar image
// height Height of avatar image
// fileSize Size of file
message AvatarImage {
    required FileLocation fileLocation = 1;
    required int32 width = 2;
    required int32 height = 3;
    required int32 fileSize = 4;
}

// Avatar of User or Group
// smallImage Optional small image of avatar box in 100x100
// largeImage Optional large image of avatar box in 200x200
// fullImage Optional full screen image of avatar
message Avatar {
    optional AvatarImage smallImage = 1;
    optional AvatarImage largeImage = 2;
    optional AvatarImage fullImage = 3;
}

// Fast thumb of media messages. Less than 90x90 and compressed by JPEG with low quality
// w Width of thumb
// h Height of thump
// thumb compressed image data
message FastThumb {
    required int32 w = 1;
    required int32 h = 2;
    required bytes thumb = 3;
}

// API#0x4D
// ResponserequestFileUrl
// Requesting file URL for downloading
// file file's location
message RequestrequestFileUrl {
    required FileLocation file = 1;
}

// API#0x4E
message ResponserequestFileUrl {
    required string url = 1;
    required int32 timeout = 2;
}

// API#0x61
// ResponserequestFileUploadUrl
// Requesting pload url
// expectedSize Expected size of uploading file. May be inaccurate. Used for size allocation optimizations.
message RequestrequestFileUploadUrl {
    required int32 expectedSize = 1;
}

// API#0x79
message ResponserequestFileUploadUrl {
    required string url = 1;
    required bytes uploadKey = 2;
}

// API#0x7A
// ResponserequestFileUploadCompleted
// Comminting uploaded file to storage
message RequestrequestFileUploadCompleted {
    required bytes uploadKey = 1;
}

// API#0x8A
message ResponserequestFileUploadCompleted {
    required FileLocation uploadedFileLocation = 1;
}

// API#0x8E
// ResponserequestFileUploadPart
// Upload file part
// uploadKey Upload Key from requestFileUploadUrl
message RequestrequestFileUploadPart {
    required int32 partNumber = 1;
    required int32 partSize = 2;
    required bytes uploadKey = 3;
}

// API#0x8D
message ResponserequestFileUploadPart {
    required string url = 1;
}

//////////////////////////////////////////////////////
// Config sync
//////////////////////////////////////////////////////
//Parameter Syncronization across devices. Can be used for simple sync
//across devices without rewriting server side code.

message Parameter {
    required string key = 1;
    required string value = 2;
}

// API#0x86
// ResponsegetParameters
message RequestgetParameters {
}

// API#0x87
message ResponsegetParameters {
    repeated Parameter parameters = 1;
}

// API#0x80
// ResponseSeq
message RequestEditParameter {
    required string key = 1;
    required string value = 2;
}

// API#0x83
message UpdateParameterChanged {
    required string key = 1;
    optional string value = 2;
}

//////////////////////////////////////////////////////
// Push
//////////////////////////////////////////////////////
//Vendor's pushes for receiving push notifications.
//Push notification contains current sequence number of main sequence.

// API#0x33
// ResponseVoid
// Registering push token on server
// projectId Project Id of token
// token token value
message RequestRegisterGooglePush {
    required int64 projectId = 1;
    required string token = 2;
}

// API#0x4C
// ResponseVoid
// Registering apple push on server
// apnsKey apns key id
// token token value
message RequestRegisterApplePush {
    required int32 apnsKey = 1;
    required string token = 2;
}

// API#0x34
// ResponseVoid
// Unregister push
message RequestUnregisterPush {
}

//////////////////////////////////////////////////////
// Peers
//////////////////////////////////////////////////////
//Peer is an identificator of specific conversation.

enum PeerType {
    PRIVATE = 1;
    GROUP = 2;
    EMAIL = 3;
}

// Peer
// type Peer Type
// id Peer Id
message Peer {
    required PeerType type = 1;
    required int32 id = 2;
}

// Out peer with access hash
// type Peer Type
// id Peer Id
// accessHash Peer access hash
message OutPeer {
    required PeerType type = 1;
    required int32 id = 2;
    required int64 accessHash = 3;
}

// User's out peer
// uid User's id
// accessHash User's access hash
message UserOutPeer {
    required int32 uid = 1;
    required int64 accessHash = 2;
}

// Group's out peer
// groupId Group's Id
// accessHash Group's access hash
message GroupOutPeer {
    required int32 groupId = 1;
    required int64 accessHash = 2;
}

//////////////////////////////////////////////////////
// Sequence and Updates
//////////////////////////////////////////////////////
//Each device has it's own update sequence. At the begining application request initial sequence state by
//calling GetState. On each application restart or NewSessionCreated application calls GetDifference for receiving
//updates in update sequence.
//GetState and GetDifference automatically subscribes session to receiving updates in session.
//Each update has seq and state. Seq is sequental index of updated and used for detecting of holes in update sequence
//(because of server failure or session die) on client side.
//All updates needed to be processed in partucular order according to seq values.
//In some updates there can be references to users that are not available at client yer. In this case application need
//to ignore such update and init getting difference.

// API#0x0D
// Sequence update
// seq Sequence number of update
// state Sequece state of update
// updateHeader header of update
// update The update
message UpdateSeqUpdate {
    required int32 seq = 1;
    required bytes state = 2;
    required int32 updateHeader = 3;
    required bytes update = 4;
}

// API#0x49
// Fat sequence update with additional data
// seq Sequence number of update
// state Sequence state of update
// updateHeader header of update
// update The update
// users Users that are referenced in update
// groups Groups that are referenced in update
message UpdateFatSeqUpdate {
    required int32 seq = 1;
    required bytes state = 2;
    required int32 updateHeader = 3;
    required bytes update = 4;
    repeated User users = 5;
    repeated Group groups = 6;
    repeated Phone phones = 7;
    repeated Email emails = 8;
}

// API#0x1A
// Out of sequence update (for typing and online statuses)
// date Date of update
// updateHeader Header of update
// update The update
message UpdateWeakUpdate {
    required int64 date = 1;
    required int32 updateHeader = 2;
    required bytes update = 3;
}

// API#0x19
// Notification about requiring performing manual GetDifference
message UpdateSeqUpdateTooLong {
}

// API#0x09
// ResponseSeq
// Get main sequence state
message RequestGetState {
}

// Update from GetDifference
// updateHeader Header of update
// update The update
message DifferenceUpdate {
    required int32 updateHeader = 1;
    required bytes update = 2;
}

// API#0x0B
// ResponseGetDifference
// Getting difference of sequence
// seq Sequence number
// state Sequence state
message RequestGetDifference {
    required int32 seq = 1;
    required bytes state = 2;
}

// API#0x0C
message ResponseGetDifference {
    required int32 seq = 1;
    required bytes state = 2;
    repeated User users = 3;
    repeated Group groups = 6;
    repeated Phone phones = 7;
    repeated Email emails = 8;
    repeated DifferenceUpdate updates = 4;
    required bool needMore = 5;
}

// API#0x20
// ResponseVoid
// Subscribing for users online
// users Users for subscription
message RequestSubscribeToOnline {
    repeated UserOutPeer users = 1;
}

// API#0x21
// ResponseVoid
// Removing subscription for users online
// users Users of subscriptions
message RequestSubscribeFromOnline {
    repeated UserOutPeer users = 1;
}

// API#0x4A
// ResponseVoid
// Subscribing for groups online
// groups Groups for subscription
message RequestSubscribeToGroupOnline {
    repeated GroupOutPeer groups = 1;
}

// API#0x4B
// ResponseVoid
// Removing subscription for groups online
// groups Groups of subscriptions
message RequestSubscribeFromGroupOnline {
    repeated GroupOutPeer groups = 1;
}

//////////////////////////////////////////////////////
// Miscellaneous
//////////////////////////////////////////////////////

// API#0x32
// Empty response
message ResponseVoid {
}

// API#0x48
// Sequence response. Methods that return this value must process response in particular order
// seq Sequence number of response
// state Sequence state of response
message ResponseSeq {
    required int32 seq = 1;
    required bytes state = 2;
}

// API#0x66
// Sequence response with date. Methods that return this value must process response in particular order
// seq Sequence number of response
// state Sequence state of response
// date Date of response
message ResponseSeqDate {
    required int32 seq = 1;
    required bytes state = 2;
    required int64 date = 3;
}

// Configuration of system
// maxGroupSize Current maximum group size
message Config {
    required int32 maxGroupSize = 1;
}

// API#0x2A
// Update about config change
// config new config
message UpdateConfig {
    required Config config = 1;
}

