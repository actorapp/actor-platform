# Authentication Key

In rev3 of protocol MTProto v2 introduces a better way of authentication of requests. In previous versions server tell authKey explictly and client apps need to pass it to every request for authentication. This is not a problem as TLS is required and everything is encrypted by default already.
But we think that can be a problem in some cases on the server side as this key flaws around the server and can occasionaly appear in server's logs. On the other side application might need to have some shared secret for performing various security related tasks, for example, sigining voice call requests.

Eventually, in rev4 of MTProto we will eliminate using of TLS for better speed and security.

MTProtoV2 uses Curve25519 for performing DH for calculating AuthKey.

This technique use [TLS 1.2 RFC](https://tools.ietf.org/html/rfc5246) for it's basis and doesn't try to invent wheel, but improves performance of TLS:

* Not sending server certificates if not needed on every connection.
* One DiffieHellman to build one shared secret without repeating on almost every reconnect. (we will implement PFS in next revision of MTProto v2)
* Using only Curve25519, AES-CBC, Kuznechik-CBC and Streebog
* Extending master_secret to make it 256 bytes long with two different algorithms based on TLS's PRF function with SHA256 and Streebog hashes.
* Added Signing of response just to check that everything is ok and add one more protection level
* **Protocol uses 256 bits of block length in HMAC instead of standart one**. This was caused by bug in initial implementation of HMAC, but doesn't affect security parameters.

# Primitives

SHA256-based pseudo-random function (https://tools.ietf.org/html/rfc5246#section-5):

```
PRF(secret: bytes, label: string, seed: bytes) = P_SHA256(secret, bytes(label) + seed);
P_SHA256(secret, seed) = SHA256(secret, A(1) + seed) + SHA256(secret, A(2) + seed) + SHA256(secret, A(3) + seed) + ...
  where A():
    A(0) = seed
    A(i) = HMAC_hash(secret, A(i-1))
```

Original key is too short - only 32 bytes and we need to extend key to more bytes in a secure way. Pseudo-code above is taken from TLS 1.2 RFC. Basic idea is to take some plain-text seed from client and server, add some fixed seed to avoid getting same hashes in different parts of a program. We use client and server seed for protecting from not that good random generators. Using text as fixed seed value is for cleaner code and specifications. In our Implementation we are performing **8** SHA256 calculations.

# New Requesting Authentication Key
Old method of AuthId creation will continue to work, but rev3 introduces new way of more secure way to get AuthId and AuthKey.

#### Server's Key Loading

Before begin you need to securely generate random long value - randomId. This is temprorary unique id used by server to identify authentication session. Server doesn't try to scope authentication procedure to single connection and even to single server and this value helps it to identify state of DH. If collision will take place it will only lead to DH failure and nothing more.


Before start Client MUST send ```RequestStartAuth``` message: 
```
RequestStartAuth {
  HEADER = 0xE0
  randomId: long
}
```

Server MUST return list of truncated to 8 bytes of SHA-256 of available keys
```
ResponseStartAuth {
  HEADER = 0xE1
  randomId: long
  availableKeys: longs
  serverNonce: bytes
}
```

Client downloads required key. Client can skip downloading keys if it have built-in keys installed.
```
RequestGetServerKey {
  HEADER = 0xE2
  keyId: long
}
```

Server return raw key data. Client MUST to check received key by comparing FULL hash that is hardcoded inside application. Again, DON'T compare truncated hashes - this is insecure. 
```
ResponseGetServerKey {
  HEADER = 0xE3
  keyId: long
  key: bytes
}
```

#### Performing Diffie Hellman

```
RequestDH {
  HEADER = 0xE6
  randomId: long
  // Used keyId
  keyId: long
  // Client's 32 securely generated bytes
  clientNonce: bytes
  // Client's key used for encryption
  clientKey: bytes
}
```

Calculations
```
pre_master_secret := <result_of_dh>
master_secret := PRF_COMBINED(pre_master_secret, "master secret", clientNonce + ServerNonce, 128)
verify := PRF_COMBINED(master_secret, "client finished", clientNonce + ServerNonce, 256)
verify_sign := Ed25519(verification, server_private_signing_key)

where PRF_COMBINED:
  PRF(COMBINE(SHA256, STREEBOG256)), where:
    COMBINE(str, HASH1, HASH2) = HASH1(str + HASH2(str))
```

master_secret is result encryption key. First 128 bytes is US encryption keys and last 128 bytes is Russian encryption keys.

```
ResponseDoDH {
  HEADER = 0xE7
  randomId: long
  verify: bytes
  verifySign: bytes
}
```
