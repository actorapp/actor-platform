# Authentication Key

In rev3 of protocol MTProto v2 introduces a better way of authentication of requests. In previous versions server tell authKey explictly and client apps need to pass it to every request for authentication. This is not a problem as TLS is required and everything is encrypted by default already.
But we think that can be a problem in some cases on the server side as this key flaws around the server and can occasionaly appear in server's logs. On the other side application might need to have some shared secret for performing various security related tasks, for example, sigining voice call requests.

Eventually, in rev4 of MTProto we will eliminate using of TLS for better speed and security.

MTProtoV2 uses Curve25519 for performing DH for calculating AuthKey.

This technique use [TLS 1.2 RFC](https://tools.ietf.org/html/rfc5246) for it's basis and doesn't try to invent wheel, but improves performance of TLS:
1) Not sending server certificates if not needed on every connection.
2) One DiffieHellman to build one shared secret without repeating on almost every reconnect. (we will implement PFS in next revision of MTProto v2)
3) Using only Curve25519 and AES-CBC

# Changes in Transport's Package

Adding new ```signature``` field for signing each package. Depends on authId server will use signature or not.
```
Package {
  // unique identifier that is constant thru all application lifetime 
  authId: long
  // random identifier of current session
  sessionId: long
  // message
  message: Message
  // signature 
  signature: bytes
}
```

# New Requesting Authentication Key
Old method of AuthId creation will continue to work, but rev3 introduces new way of more secure way to get AuthId and AuthKey.

#### Server's Key Loading

Before begin you need to securely generate random long value - randomId. This is temprorary unique id used by server to identify authentication session. Server doesn't try to scope authentication procedure to single connection and even to single server and this value helps it to identify state of DH. If collision will take place it will only lead to DH failure and nothing more.


Before start Client MUST send ```RequestStartAuth``` message: 
```
RequestStartAuth {
  HEADER = 0xE0
  randomId: long
}
```

Server MUST return list of truncated to 8 bytes of SHA-256 of available keys
```
ResponseStartAuth {
  HEADER = 0xE1
  randomId: long
  availableKeys: longs
  serverNonce: bytes
}
```

Client downloads required key. Client can skip downloading keys if it have built-in keys installed.
```
ResponseGetServerKey {
  HEADER = 0xE2
  keyId: long
}
```

Server return raw key data. Client MUST to check received key by comparing FULL hash that is hardcoded inside application. Again, DON'T compare truncated hashes - this is insecure. 
```
ResponseGetServerKey {
  HEADER = 0xE3
  keyId: long
  key: bytes
}
```

#### Performing Diffie Hellman

```
RequestDH {
  HEADER = 0xE6
  randomId: long
  // Used keyId
  keyId: long
  // Client's 32 securely generated bytes
  clientNonce: bytes
  // Client's key used for encryption
  clientKey: bytes
  //Encrypted DH request
  encrypted: bytes
}
```

Calculations
```
pre_master_secret := <result_of_dh>
master_secret := SHA256(pre_master_secret, "master secret", clientNonce, ServerNonce)
aes_key := subs(encryption_key, 0, 16)
aes_iv := subs(encryption_key, 16, 16)
encrypted := AES-CBC(<data>, aes_key, aes_iv)
```

```
ResponseDoDH {
  HEADER = 0xE7
  randomId: long
}
```
